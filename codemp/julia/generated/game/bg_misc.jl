BG_FileExists( fileName_ ) = ccall((:BG_FileExists, lib), qboolean, ( Ptr{Char},  ), fileName_ );
BG_GiveMeVectorFromMatrix( boltMatrix_, flags_, vec_ ) = ccall((:BG_GiveMeVectorFromMatrix, lib), Void, ( Ptr{mdxaBone_t}, Int32, vec3_t,  ), boltMatrix_, flags_, vec_ );
BG_LegalizedForcePowers( powerOut_, powerOutSize_, maxRank_, freeSaber_, teamForce_, gametype_, fpDisabled_ ) = ccall((:BG_LegalizedForcePowers, lib), qboolean, ( Ptr{Char}, size_t, Int32, qboolean, Int32, Int32, Int32,  ), powerOut_, powerOutSize_, maxRank_, freeSaber_, teamForce_, gametype_, fpDisabled_ );
vectoyaw( vec_ ) = ccall((:vectoyaw, lib), Float32, ( vec3_t,  ), vec_ );
BG_HasYsalamiri( gametype_, ps_ ) = ccall((:BG_HasYsalamiri, lib), qboolean, ( Int32, Ptr{playerState_t},  ), gametype_, ps_ );
BG_CanUseFPNow( gametype_, ps_, time_, power_ ) = ccall((:BG_CanUseFPNow, lib), qboolean, ( Int32, Ptr{playerState_t}, Int32, forcePowers_t,  ), gametype_, ps_, time_, power_ );
BG_FindItemForPowerup( pw_ ) = ccall((:BG_FindItemForPowerup, lib), Ptr{gitem_t}, ( powerup_t,  ), pw_ );
BG_FindItemForHoldable( pw_ ) = ccall((:BG_FindItemForHoldable, lib), Ptr{gitem_t}, ( holdable_t,  ), pw_ );
BG_FindItemForWeapon( weapon_ ) = ccall((:BG_FindItemForWeapon, lib), Ptr{gitem_t}, ( weapon_t,  ), weapon_ );
BG_FindItemForAmmo( ammo_ ) = ccall((:BG_FindItemForAmmo, lib), Ptr{gitem_t}, ( ammo_t,  ), ammo_ );
BG_FindItem( classname_ ) = ccall((:BG_FindItem, lib), Ptr{gitem_t}, ( Ptr{Char},  ), classname_ );
BG_PlayerTouchesItem( ps_, item_, atTime_ ) = ccall((:BG_PlayerTouchesItem, lib), qboolean, ( Ptr{playerState_t}, Ptr{entityState_t}, Int32,  ), ps_, item_, atTime_ );
BG_ProperForceIndex( power_ ) = ccall((:BG_ProperForceIndex, lib), Int32, ( Int32,  ), power_ );
BG_CycleForce( ps_, direction_ ) = ccall((:BG_CycleForce, lib), Void, ( Ptr{playerState_t}, Int32,  ), ps_, direction_ );
BG_GetItemIndexByTag( tag_, type_ ) = ccall((:BG_GetItemIndexByTag, lib), Int32, ( Int32, Int32,  ), tag_, type_ );
BG_IsItemSelectable( ps_, item_ ) = ccall((:BG_IsItemSelectable, lib), qboolean, ( Ptr{playerState_t}, Int32,  ), ps_, item_ );
BG_CycleInven( ps_, direction_ ) = ccall((:BG_CycleInven, lib), Void, ( Ptr{playerState_t}, Int32,  ), ps_, direction_ );
BG_CanItemBeGrabbed( gametype_, ent_, ps_ ) = ccall((:BG_CanItemBeGrabbed, lib), qboolean, ( Int32, Ptr{entityState_t}, Ptr{playerState_t},  ), gametype_, ent_, ps_ );
BG_EvaluateTrajectory( tr_, atTime_, result_ ) = ccall((:BG_EvaluateTrajectory, lib), Void, ( Ptr{trajectory_t}, Int32, vec3_t,  ), tr_, atTime_, result_ );
BG_EvaluateTrajectoryDelta( tr_, atTime_, result_ ) = ccall((:BG_EvaluateTrajectoryDelta, lib), Void, ( Ptr{trajectory_t}, Int32, vec3_t,  ), tr_, atTime_, result_ );
BG_AddPredictableEventToPlayerstate( newEvent_, eventParm_, ps_ ) = ccall((:BG_AddPredictableEventToPlayerstate, lib), Void, ( Int32, Int32, Ptr{playerState_t},  ), newEvent_, eventParm_, ps_ );
BG_TouchJumpPad( ps_, jumppad_ ) = ccall((:BG_TouchJumpPad, lib), Void, ( Ptr{playerState_t}, Ptr{entityState_t},  ), ps_, jumppad_ );
BG_EmplacedView( baseAngles_, angles_, newYaw_, constraint_ ) = ccall((:BG_EmplacedView, lib), Int32, ( vec3_t, vec3_t, Ptr{Float32}, Float32,  ), baseAngles_, angles_, newYaw_, constraint_ );
BG_IsValidCharacterModel( modelName_, skinName_ ) = ccall((:BG_IsValidCharacterModel, lib), qboolean, ( Ptr{Char}, Ptr{Char},  ), modelName_, skinName_ );
BG_ValidateSkinForTeam( modelName_, skinName_, team_, colors_ ) = ccall((:BG_ValidateSkinForTeam, lib), qboolean, ( Ptr{Char}, Ptr{Char}, Int32, Ptr{Float32},  ), modelName_, skinName_, team_, colors_ );
BG_PlayerStateToEntityState( ps_, s_, snap_ ) = ccall((:BG_PlayerStateToEntityState, lib), Void, ( Ptr{playerState_t}, Ptr{entityState_t}, qboolean,  ), ps_, s_, snap_ );
BG_PlayerStateToEntityStateExtraPolate( ps_, s_, time_, snap_ ) = ccall((:BG_PlayerStateToEntityStateExtraPolate, lib), Void, ( Ptr{playerState_t}, Ptr{entityState_t}, Int32, qboolean,  ), ps_, s_, time_, snap_ );
BG_ModelCache( modelName_, skinName_ ) = ccall((:BG_ModelCache, lib), Int32, ( Ptr{Char}, Ptr{Char},  ), modelName_, skinName_ );
BG_Alloc( size_ ) = ccall((:BG_Alloc, lib), Ptr{Void}, ( Int32,  ), size_ );
BG_AllocUnaligned( size_ ) = ccall((:BG_AllocUnaligned, lib), Ptr{Void}, ( Int32,  ), size_ );
BG_TempAlloc( size_ ) = ccall((:BG_TempAlloc, lib), Ptr{Void}, ( Int32,  ), size_ );
BG_TempFree( size_ ) = ccall((:BG_TempFree, lib), Void, ( Int32,  ), size_ );
BG_StringAlloc( source_ ) = ccall((:BG_StringAlloc, lib), Ptr{Char}, ( Ptr{Char},  ), source_ );
BG_OutOfMemory() = ccall((:BG_OutOfMemory, lib), qboolean, (),  );
BG_GetGametypeString( gametype_ ) = ccall((:BG_GetGametypeString, lib), Ptr{Char}, ( Int32,  ), gametype_ );
BG_GetGametypeForString( gametype_ ) = ccall((:BG_GetGametypeForString, lib), Int32, ( Ptr{Char},  ), gametype_ );
