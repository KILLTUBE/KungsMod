G_PlayDoorLoopSound( ent_ ) = ccall((:G_PlayDoorLoopSound, lib), Void, ( Ptr{gentity_t},  ), ent_ );
G_PlayDoorSound( ent_, type_ ) = ccall((:G_PlayDoorSound, lib), Void, ( Ptr{gentity_t}, Int32,  ), ent_, type_ );
G_TestEntityPosition( ent_ ) = ccall((:G_TestEntityPosition, lib), Ptr{gentity_t}, ( Ptr{gentity_t},  ), ent_ );
G_CreateRotationMatrix( angles_, matrix_ ) = ccall((:G_CreateRotationMatrix, lib), Void, ( vec3_t, matrix3_t,  ), angles_, matrix_ );
G_TransposeMatrix( matrix_, transpose_ ) = ccall((:G_TransposeMatrix, lib), Void, ( matrix3_t, matrix3_t,  ), matrix_, transpose_ );
G_RotatePoint( point_, matrix_ ) = ccall((:G_RotatePoint, lib), Void, ( vec3_t, matrix3_t,  ), point_, matrix_ );
G_TryPushingEntity( check_, pusher_, move_, amove_ ) = ccall((:G_TryPushingEntity, lib), qboolean, ( Ptr{gentity_t}, Ptr{gentity_t}, vec3_t, vec3_t,  ), check_, pusher_, move_, amove_ );
G_MoverPush( pusher_, move_, amove_, obstacle_ ) = ccall((:G_MoverPush, lib), qboolean, ( Ptr{gentity_t}, vec3_t, vec3_t, Ptr{Ptr{gentity_t}},  ), pusher_, move_, amove_, obstacle_ );
G_MoverTeam( ent_ ) = ccall((:G_MoverTeam, lib), Void, ( Ptr{gentity_t},  ), ent_ );
G_RunMover( ent_ ) = ccall((:G_RunMover, lib), Void, ( Ptr{gentity_t},  ), ent_ );
CalcTeamDoorCenter( ent_, center_ ) = ccall((:CalcTeamDoorCenter, lib), Void, ( Ptr{gentity_t}, vec3_t,  ), ent_, center_ );
SetMoverState( ent_, moverState_, time_ ) = ccall((:SetMoverState, lib), Void, ( Ptr{gentity_t}, moverState_t, Int32,  ), ent_, moverState_, time_ );
MatchTeam( teamLeader_, moverState_, time_ ) = ccall((:MatchTeam, lib), Void, ( Ptr{gentity_t}, Int32, Int32,  ), teamLeader_, moverState_, time_ );
ReturnToPos1( ent_ ) = ccall((:ReturnToPos1, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Reached_BinaryMover( ent_ ) = ccall((:Reached_BinaryMover, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Use_BinaryMover_Go( ent_ ) = ccall((:Use_BinaryMover_Go, lib), Void, ( Ptr{gentity_t},  ), ent_ );
UnLockDoors( ent_ ) = ccall((:UnLockDoors, lib), Void, ( Ptr{gentity_t},  ), ent_ );
LockDoors( ent_ ) = ccall((:LockDoors, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Use_BinaryMover( ent_, other_, activator_ ) = ccall((:Use_BinaryMover, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, other_, activator_ );
InitMoverTrData( ent_ ) = ccall((:InitMoverTrData, lib), Void, ( Ptr{gentity_t},  ), ent_ );
InitMover( ent_ ) = ccall((:InitMover, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Blocked_Door( ent_, other_ ) = ccall((:Blocked_Door, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, other_ );
Touch_DoorTriggerSpectator( ent_, other_, trace_ ) = ccall((:Touch_DoorTriggerSpectator, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{trace_t},  ), ent_, other_, trace_ );
Touch_DoorTrigger( ent_, other_, trace_ ) = ccall((:Touch_DoorTrigger, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{trace_t},  ), ent_, other_, trace_ );
Think_SpawnNewDoorTrigger( ent_ ) = ccall((:Think_SpawnNewDoorTrigger, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Think_MatchTeam( ent_ ) = ccall((:Think_MatchTeam, lib), Void, ( Ptr{gentity_t},  ), ent_ );
G_EntIsDoor( entityNum_ ) = ccall((:G_EntIsDoor, lib), qboolean, ( Int32,  ), entityNum_ );
G_FindDoorTrigger( ent_ ) = ccall((:G_FindDoorTrigger, lib), Ptr{gentity_t}, ( Ptr{gentity_t},  ), ent_ );
G_EntIsUnlockedDoor( entityNum_ ) = ccall((:G_EntIsUnlockedDoor, lib), qboolean, ( Int32,  ), entityNum_ );
SP_func_door( ent_ ) = ccall((:SP_func_door, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Touch_Plat( ent_, other_, trace_ ) = ccall((:Touch_Plat, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{trace_t},  ), ent_, other_, trace_ );
Touch_PlatCenterTrigger( ent_, other_, trace_ ) = ccall((:Touch_PlatCenterTrigger, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{trace_t},  ), ent_, other_, trace_ );
SpawnPlatTrigger( ent_ ) = ccall((:SpawnPlatTrigger, lib), Void, ( Ptr{gentity_t},  ), ent_ );
SP_func_plat( ent_ ) = ccall((:SP_func_plat, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Touch_Button( ent_, other_, trace_ ) = ccall((:Touch_Button, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{trace_t},  ), ent_, other_, trace_ );
SP_func_button( ent_ ) = ccall((:SP_func_button, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Think_BeginMoving( ent_ ) = ccall((:Think_BeginMoving, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Reached_Train( ent_ ) = ccall((:Reached_Train, lib), Void, ( Ptr{gentity_t},  ), ent_ );
Think_SetupTrainTargets( ent_ ) = ccall((:Think_SetupTrainTargets, lib), Void, ( Ptr{gentity_t},  ), ent_ );
SP_path_corner( self_ ) = ccall((:SP_path_corner, lib), Void, ( Ptr{gentity_t},  ), self_ );
SP_func_train( self_ ) = ccall((:SP_func_train, lib), Void, ( Ptr{gentity_t},  ), self_ );
SP_func_static( ent_ ) = ccall((:SP_func_static, lib), Void, ( Ptr{gentity_t},  ), ent_ );
func_static_use( self_, other_, activator_ ) = ccall((:func_static_use, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), self_, other_, activator_ );
func_rotating_use( self_, other_, activator_ ) = ccall((:func_rotating_use, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), self_, other_, activator_ );
SP_func_rotating( ent_ ) = ccall((:SP_func_rotating, lib), Void, ( Ptr{gentity_t},  ), ent_ );
SP_func_bobbing( ent_ ) = ccall((:SP_func_bobbing, lib), Void, ( Ptr{gentity_t},  ), ent_ );
SP_func_pendulum( ent_ ) = ccall((:SP_func_pendulum, lib), Void, ( Ptr{gentity_t},  ), ent_ );
CacheChunkEffects( material_ ) = ccall((:CacheChunkEffects, lib), Void, ( material_t,  ), material_ );
G_MiscModelExplosion( mins_, maxs_, size_, chunkType_ ) = ccall((:G_MiscModelExplosion, lib), Void, ( vec3_t, vec3_t, Int32, material_t,  ), mins_, maxs_, size_, chunkType_ );
G_Chunks( owner_, origin_, normal_, mins_, maxs_, speed_, numChunks_, chunkType_, customChunk_, baseScale_ ) = ccall((:G_Chunks, lib), Void, ( Int32, vec3_t, vec3_t, vec3_t, vec3_t, Float32, Int32, material_t, Int32, Float32,  ), owner_, origin_, normal_, mins_, maxs_, speed_, numChunks_, chunkType_, customChunk_, baseScale_ );
funcBBrushDieGo( self_ ) = ccall((:funcBBrushDieGo, lib), Void, ( Ptr{gentity_t},  ), self_ );
funcBBrushDie( self_, inflictor_, attacker_, damage_, mod_ ) = ccall((:funcBBrushDie, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t}, Int32, Int32,  ), self_, inflictor_, attacker_, damage_, mod_ );
funcBBrushUse( self_, other_, activator_ ) = ccall((:funcBBrushUse, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), self_, other_, activator_ );
funcBBrushPain( self_, attacker_, damage_ ) = ccall((:funcBBrushPain, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Int32,  ), self_, attacker_, damage_ );
InitBBrush( ent_ ) = ccall((:InitBBrush, lib), Void, ( Ptr{gentity_t},  ), ent_ );
funcBBrushTouch( ent_, other_, trace_ ) = ccall((:funcBBrushTouch, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{trace_t},  ), ent_, other_, trace_ );
SP_func_breakable( self_ ) = ccall((:SP_func_breakable, lib), Void, ( Ptr{gentity_t},  ), self_ );
G_EntIsBreakable( entityNum_ ) = ccall((:G_EntIsBreakable, lib), qboolean, ( Int32,  ), entityNum_ );
GlassDie( self_, inflictor_, attacker_, damage_, mod_ ) = ccall((:GlassDie, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t}, Int32, Int32,  ), self_, inflictor_, attacker_, damage_, mod_ );
GlassDie_Old( self_, inflictor_, attacker_, damage_, mod_ ) = ccall((:GlassDie_Old, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t}, Int32, Int32,  ), self_, inflictor_, attacker_, damage_, mod_ );
GlassPain( self_, attacker_, damage_ ) = ccall((:GlassPain, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Int32,  ), self_, attacker_, damage_ );
GlassUse( self_, other_, activator_ ) = ccall((:GlassUse, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), self_, other_, activator_ );
SP_func_glass( ent_ ) = ccall((:SP_func_glass, lib), Void, ( Ptr{gentity_t},  ), ent_ );
func_wait_return_solid( self_ ) = ccall((:func_wait_return_solid, lib), Void, ( Ptr{gentity_t},  ), self_ );
func_usable_think( self_ ) = ccall((:func_usable_think, lib), Void, ( Ptr{gentity_t},  ), self_ );
G_EntIsRemovableUsable( entNum_ ) = ccall((:G_EntIsRemovableUsable, lib), qboolean, ( Int32,  ), entNum_ );
func_usable_use( self_, other_, activator_ ) = ccall((:func_usable_use, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), self_, other_, activator_ );
func_usable_pain( self_, attacker_, damage_ ) = ccall((:func_usable_pain, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Int32,  ), self_, attacker_, damage_ );
func_usable_die( self_, inflictor_, attacker_, damage_, mod_ ) = ccall((:func_usable_die, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t}, Int32, Int32,  ), self_, inflictor_, attacker_, damage_, mod_ );
SP_func_usable( self_ ) = ccall((:SP_func_usable, lib), Void, ( Ptr{gentity_t},  ), self_ );
use_wall( ent_, other_, activator_ ) = ccall((:use_wall, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, other_, activator_ );
SP_func_wall( ent_ ) = ccall((:SP_func_wall, lib), Void, ( Ptr{gentity_t},  ), ent_ );
