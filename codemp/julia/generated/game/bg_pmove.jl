PM_BGEntForNum( num_ ) = ccall((:PM_BGEntForNum, lib), Ptr{bgEntity_t}, ( Int32,  ), num_ );
BG_SabersOff( ps_ ) = ccall((:BG_SabersOff, lib), qboolean, ( Ptr{playerState_t},  ), ps_ );
BG_KnockDownable( ps_ ) = ccall((:BG_KnockDownable, lib), qboolean, ( Ptr{playerState_t},  ), ps_ );
PM_IsRocketTrooper() = ccall((:PM_IsRocketTrooper, lib), qboolean, (),  );
PM_GetSaberStance() = ccall((:PM_GetSaberStance, lib), Int32, (),  );
PM_DoSlowFall() = ccall((:PM_DoSlowFall, lib), qboolean, (),  );
PM_pitch_roll_for_slope( forwhom_, pass_slope_, storeAngles_ ) = ccall((:PM_pitch_roll_for_slope, lib), Void, ( Ptr{bgEntity_t}, vec3_t, vec3_t,  ), forwhom_, pass_slope_, storeAngles_ );
PM_SetSpecialMoveValues() = ccall((:PM_SetSpecialMoveValues, lib), Void, (),  );
PM_SetVehicleAngles( normal_ ) = ccall((:PM_SetVehicleAngles, lib), Void, ( vec3_t,  ), normal_ );
BG_VehicleTurnRateForSpeed( pVeh_, speed_, mPitchOverride_, mYawOverride_ ) = ccall((:BG_VehicleTurnRateForSpeed, lib), Void, ( Ptr{Vehicle_t}, Float32, Ptr{Float32}, Ptr{Float32},  ), pVeh_, speed_, mPitchOverride_, mYawOverride_ );
PM_HoverTrace() = ccall((:PM_HoverTrace, lib), Void, (),  );
PM_AddEvent( newEvent_ ) = ccall((:PM_AddEvent, lib), Void, ( Int32,  ), newEvent_ );
PM_AddEventWithParm( newEvent_, parm_ ) = ccall((:PM_AddEventWithParm, lib), Void, ( Int32, Int32,  ), newEvent_, parm_ );
PM_AddTouchEnt( entityNum_ ) = ccall((:PM_AddTouchEnt, lib), Void, ( Int32,  ), entityNum_ );
PM_ClipVelocity( in_, normal_, out_, overbounce_ ) = ccall((:PM_ClipVelocity, lib), Void, ( vec3_t, vec3_t, vec3_t, Float32,  ), in_, normal_, out_, overbounce_ );
PM_Friction() = ccall((:PM_Friction, lib), Void, (),  );
PM_Accelerate( wishdir_, wishspeed_, accel_ ) = ccall((:PM_Accelerate, lib), Void, ( vec3_t, Float32, Float32,  ), wishdir_, wishspeed_, accel_ );
PM_CmdScale( cmd_ ) = ccall((:PM_CmdScale, lib), Float32, ( Ptr{usercmd_t},  ), cmd_ );
PM_SetMovementDir() = ccall((:PM_SetMovementDir, lib), Void, (),  );
PM_ForceJumpingUp() = ccall((:PM_ForceJumpingUp, lib), qboolean, (),  );
PM_JumpForDir() = ccall((:PM_JumpForDir, lib), Void, (),  );
PM_SetPMViewAngle( ps_, angle_, ucmd_ ) = ccall((:PM_SetPMViewAngle, lib), Void, ( Ptr{playerState_t}, vec3_t, Ptr{usercmd_t},  ), ps_, angle_, ucmd_ );
PM_AdjustAngleForWallRun( ps_, ucmd_, doMove_ ) = ccall((:PM_AdjustAngleForWallRun, lib), qboolean, ( Ptr{playerState_t}, Ptr{usercmd_t}, qboolean,  ), ps_, ucmd_, doMove_ );
PM_AdjustAnglesForWallRunUpFlipAlt( ucmd_ ) = ccall((:PM_AdjustAnglesForWallRunUpFlipAlt, lib), qboolean, ( Ptr{usercmd_t},  ), ucmd_ );
PM_AdjustAngleForWallRunUp( ps_, ucmd_, doMove_ ) = ccall((:PM_AdjustAngleForWallRunUp, lib), qboolean, ( Ptr{playerState_t}, Ptr{usercmd_t}, qboolean,  ), ps_, ucmd_, doMove_ );
BG_ForceWallJumpStrength() = ccall((:BG_ForceWallJumpStrength, lib), Float32, (),  );
PM_AdjustAngleForWallJump( ps_, ucmd_, doMove_ ) = ccall((:PM_AdjustAngleForWallJump, lib), qboolean, ( Ptr{playerState_t}, Ptr{usercmd_t}, qboolean,  ), ps_, ucmd_, doMove_ );
PM_SetForceJumpZStart( value_ ) = ccall((:PM_SetForceJumpZStart, lib), Void, ( Float32,  ), value_ );
PM_GrabWallForJump( anim_ ) = ccall((:PM_GrabWallForJump, lib), Void, ( Int32,  ), anim_ );
PM_CheckJump() = ccall((:PM_CheckJump, lib), qboolean, (),  );
PM_CheckWaterJump() = ccall((:PM_CheckWaterJump, lib), qboolean, (),  );
PM_WaterJumpMove() = ccall((:PM_WaterJumpMove, lib), Void, (),  );
PM_WaterMove() = ccall((:PM_WaterMove, lib), Void, (),  );
PM_FlyVehicleMove() = ccall((:PM_FlyVehicleMove, lib), Void, (),  );
PM_FlyMove() = ccall((:PM_FlyMove, lib), Void, (),  );
PM_AirMove() = ccall((:PM_AirMove, lib), Void, (),  );
PM_WalkMove() = ccall((:PM_WalkMove, lib), Void, (),  );
PM_DeadMove() = ccall((:PM_DeadMove, lib), Void, (),  );
PM_NoclipMove() = ccall((:PM_NoclipMove, lib), Void, (),  );
PM_FootstepForSurface() = ccall((:PM_FootstepForSurface, lib), Int32, (),  );
PM_TryRoll() = ccall((:PM_TryRoll, lib), Int32, (),  );
PM_CrashLandEffect() = ccall((:PM_CrashLandEffect, lib), Void, (),  );
PM_CrashLand() = ccall((:PM_CrashLand, lib), Void, (),  );
PM_CorrectAllSolid( trace_ ) = ccall((:PM_CorrectAllSolid, lib), Int32, ( Ptr{trace_t},  ), trace_ );
PM_GroundTraceMissed() = ccall((:PM_GroundTraceMissed, lib), Void, (),  );
PM_GroundTrace() = ccall((:PM_GroundTrace, lib), Void, (),  );
PM_SetWaterLevel() = ccall((:PM_SetWaterLevel, lib), Void, (),  );
PM_CheckDualForwardJumpDuck() = ccall((:PM_CheckDualForwardJumpDuck, lib), qboolean, (),  );
PM_CheckFixMins() = ccall((:PM_CheckFixMins, lib), Void, (),  );
PM_CanStand() = ccall((:PM_CanStand, lib), qboolean, (),  );
PM_CheckDuck() = ccall((:PM_CheckDuck, lib), Void, (),  );
PM_Use() = ccall((:PM_Use, lib), Void, (),  );
PM_WalkingAnim( anim_ ) = ccall((:PM_WalkingAnim, lib), qboolean, ( Int32,  ), anim_ );
PM_RunningAnim( anim_ ) = ccall((:PM_RunningAnim, lib), qboolean, ( Int32,  ), anim_ );
PM_SwimmingAnim( anim_ ) = ccall((:PM_SwimmingAnim, lib), qboolean, ( Int32,  ), anim_ );
PM_RollingAnim( anim_ ) = ccall((:PM_RollingAnim, lib), qboolean, ( Int32,  ), anim_ );
PM_AnglesForSlope( yaw_, slope_, angles_ ) = ccall((:PM_AnglesForSlope, lib), Void, ( Float32, vec3_t, vec3_t,  ), yaw_, slope_, angles_ );
PM_FootSlopeTrace( pDiff_, pInterval_ ) = ccall((:PM_FootSlopeTrace, lib), Void, ( Ptr{Float32}, Ptr{Float32},  ), pDiff_, pInterval_ );
BG_InSlopeAnim( anim_ ) = ccall((:BG_InSlopeAnim, lib), qboolean, ( Int32,  ), anim_ );
PM_AdjustStandAnimForSlope() = ccall((:PM_AdjustStandAnimForSlope, lib), qboolean, (),  );
PM_LegsSlopeBackTransition( desiredAnim_ ) = ccall((:PM_LegsSlopeBackTransition, lib), Int32, ( Int32,  ), desiredAnim_ );
PM_Footsteps() = ccall((:PM_Footsteps, lib), Void, (),  );
PM_WaterEvents() = ccall((:PM_WaterEvents, lib), Void, (),  );
BG_ClearRocketLock( ps_ ) = ccall((:BG_ClearRocketLock, lib), Void, ( Ptr{playerState_t},  ), ps_ );
PM_BeginWeaponChange( weapon_ ) = ccall((:PM_BeginWeaponChange, lib), Void, ( Int32,  ), weapon_ );
PM_FinishWeaponChange() = ccall((:PM_FinishWeaponChange, lib), Void, (),  );
BG_VehTraceFromCamPos( camTrace_, bgEnt_, entOrg_, shotStart_, end_, newEnd_, shotDir_, bestDist_ ) = ccall((:BG_VehTraceFromCamPos, lib), Int32, ( Ptr{trace_t}, Ptr{bgEntity_t}, vec3_t, vec3_t, vec3_t, vec3_t, vec3_t, Float32,  ), camTrace_, bgEnt_, entOrg_, shotStart_, end_, newEnd_, shotDir_, bestDist_ );
PM_RocketLock( lockDist_, vehicleLock_ ) = ccall((:PM_RocketLock, lib), Void, ( Float32, qboolean,  ), lockDist_, vehicleLock_ );
PM_DoChargedWeapons( vehicleRocketLock_, veh_ ) = ccall((:PM_DoChargedWeapons, lib), qboolean, ( qboolean, Ptr{bgEntity_t},  ), vehicleRocketLock_, veh_ );
PM_ItemUsable( ps_, forcedUse_ ) = ccall((:PM_ItemUsable, lib), Int32, ( Ptr{playerState_t}, Int32,  ), ps_, forcedUse_ );
PM_CanSetWeaponAnims() = ccall((:PM_CanSetWeaponAnims, lib), qboolean, (),  );
PM_VehicleWeaponAnimate() = ccall((:PM_VehicleWeaponAnimate, lib), Void, (),  );
PM_Weapon() = ccall((:PM_Weapon, lib), Void, (),  );
PM_Animate() = ccall((:PM_Animate, lib), Void, (),  );
PM_DropTimers() = ccall((:PM_DropTimers, lib), Void, (),  );
BG_UnrestrainedPitchRoll( ps_, pVeh_ ) = ccall((:BG_UnrestrainedPitchRoll, lib), qboolean, ( Ptr{playerState_t}, Ptr{Vehicle_t},  ), ps_, pVeh_ );
PM_UpdateViewAngles( ps_, cmd_ ) = ccall((:PM_UpdateViewAngles, lib), Void, ( Ptr{playerState_t}, Ptr{usercmd_t},  ), ps_, cmd_ );
PM_AdjustAttackStates( pmove_ ) = ccall((:PM_AdjustAttackStates, lib), Void, ( Ptr{pmove_t},  ), pmove_ );
BG_CmdForRoll( ps_, anim_, pCmd_ ) = ccall((:BG_CmdForRoll, lib), Void, ( Ptr{playerState_t}, Int32, Ptr{usercmd_t},  ), ps_, anim_, pCmd_ );
BG_AdjustClientSpeed( ps_, cmd_, svTime_ ) = ccall((:BG_AdjustClientSpeed, lib), Void, ( Ptr{playerState_t}, Ptr{usercmd_t}, Int32,  ), ps_, cmd_, svTime_ );
BG_InRollAnim( cent_ ) = ccall((:BG_InRollAnim, lib), qboolean, ( Ptr{entityState_t},  ), cent_ );
BG_InKnockDown( anim_ ) = ccall((:BG_InKnockDown, lib), qboolean, ( Int32,  ), anim_ );
BG_InRollES( ps_, anim_ ) = ccall((:BG_InRollES, lib), qboolean, ( Ptr{entityState_t}, Int32,  ), ps_, anim_ );
BG_IK_MoveArm( ghoul2_, lHandBolt_, time_, ent_, basePose_, desiredPos_, ikInProgress_, origin_, angles_, scale_, blendTime_, forceHalt_ ) = ccall((:BG_IK_MoveArm, lib), Void, ( Ptr{Void}, Int32, Int32, Ptr{entityState_t}, Int32, vec3_t, Ptr{qboolean}, vec3_t, vec3_t, vec3_t, Int32, qboolean,  ), ghoul2_, lHandBolt_, time_, ent_, basePose_, desiredPos_, ikInProgress_, origin_, angles_, scale_, blendTime_, forceHalt_ );
BG_UpdateLookAngles( lookingDebounceTime_, lastHeadAngles_, time_, lookAngles_, lookSpeed_, minPitch_, maxPitch_, minYaw_, maxYaw_, minRoll_, maxRoll_ ) = ccall((:BG_UpdateLookAngles, lib), Void, ( Int32, vec3_t, Int32, vec3_t, Float32, Float32, Float32, Float32, Float32, Float32, Float32,  ), lookingDebounceTime_, lastHeadAngles_, time_, lookAngles_, lookSpeed_, minPitch_, maxPitch_, minYaw_, maxYaw_, minRoll_, maxRoll_ );
BG_G2ClientNeckAngles( ghoul2_, time_, lookAngles_, headAngles_, neckAngles_, thoracicAngles_, headClampMinAngles_, headClampMaxAngles_ ) = ccall((:BG_G2ClientNeckAngles, lib), Void, ( Ptr{Void}, Int32, vec3_t, vec3_t, vec3_t, vec3_t, vec3_t, vec3_t,  ), ghoul2_, time_, lookAngles_, headAngles_, neckAngles_, thoracicAngles_, headClampMinAngles_, headClampMaxAngles_ );
BG_G2ClientSpineAngles( ghoul2_, motionBolt_, cent_lerpOrigin_, cent_lerpAngles_, cent_, time_, viewAngles_, ciLegs_, ciTorso_, angles_, thoracicAngles_, ulAngles_, llAngles_, modelScale_, tPitchAngle_, tYawAngle_, corrTime_ ) = ccall((:BG_G2ClientSpineAngles, lib), Void, ( Ptr{Void}, Int32, vec3_t, vec3_t, Ptr{entityState_t}, Int32, vec3_t, Int32, Int32, vec3_t, vec3_t, vec3_t, vec3_t, vec3_t, Ptr{Float32}, Ptr{Float32}, Ptr{Int32},  ), ghoul2_, motionBolt_, cent_lerpOrigin_, cent_lerpAngles_, cent_, time_, viewAngles_, ciLegs_, ciTorso_, angles_, thoracicAngles_, ulAngles_, llAngles_, modelScale_, tPitchAngle_, tYawAngle_, corrTime_ );
BG_SwingAngles( destination_, swingTolerance_, clampTolerance_, speed_, angle_, swinging_, frametime_ ) = ccall((:BG_SwingAngles, lib), Float32, ( Float32, Float32, Float32, Float32, Ptr{Float32}, Ptr{qboolean}, Int32,  ), destination_, swingTolerance_, clampTolerance_, speed_, angle_, swinging_, frametime_ );
BG_InRoll2( es_ ) = ccall((:BG_InRoll2, lib), qboolean, ( Ptr{entityState_t},  ), es_ );
BG_G2PlayerAngles( ghoul2_, motionBolt_, cent_, time_, cent_lerpOrigin_, cent_lerpAngles_, legs_, legsAngles_, tYawing_, tPitching_, lYawing_, tYawAngle_, tPitchAngle_, lYawAngle_, frametime_, turAngles_, modelScale_, ciLegs_, ciTorso_, corrTime_, lookAngles_, lastHeadAngles_, lookTime_, emplaced_, crazySmoothFactor_ ) = ccall((:BG_G2PlayerAngles, lib), Void, ( Ptr{Void}, Int32, Ptr{entityState_t}, Int32, vec3_t, vec3_t, matrix3_t, vec3_t, Ptr{qboolean}, Ptr{qboolean}, Ptr{qboolean}, Ptr{Float32}, Ptr{Float32}, Ptr{Float32}, Int32, vec3_t, vec3_t, Int32, Int32, Ptr{Int32}, vec3_t, vec3_t, Int32, Ptr{entityState_t}, Ptr{Int32},  ), ghoul2_, motionBolt_, cent_, time_, cent_lerpOrigin_, cent_lerpAngles_, legs_, legsAngles_, tYawing_, tPitching_, lYawing_, tYawAngle_, tPitchAngle_, lYawAngle_, frametime_, turAngles_, modelScale_, ciLegs_, ciTorso_, corrTime_, lookAngles_, lastHeadAngles_, lookTime_, emplaced_, crazySmoothFactor_ );
BG_G2ATSTAngles( ghoul2_, time_, cent_lerpAngles_ ) = ccall((:BG_G2ATSTAngles, lib), Void, ( Ptr{Void}, Int32, vec3_t,  ), ghoul2_, time_, cent_lerpAngles_ );
PM_AdjustAnglesForDualJumpAttack( ps_, ucmd_ ) = ccall((:PM_AdjustAnglesForDualJumpAttack, lib), qboolean, ( Ptr{playerState_t}, Ptr{usercmd_t},  ), ps_, ucmd_ );
PM_CmdForSaberMoves( ucmd_ ) = ccall((:PM_CmdForSaberMoves, lib), Void, ( Ptr{usercmd_t},  ), ucmd_ );
PM_VehicleViewAngles( ps_, veh_, ucmd_ ) = ccall((:PM_VehicleViewAngles, lib), Void, ( Ptr{playerState_t}, Ptr{bgEntity_t}, Ptr{usercmd_t},  ), ps_, veh_, ucmd_ );
PM_WeaponOkOnVehicle( weapon_ ) = ccall((:PM_WeaponOkOnVehicle, lib), qboolean, ( Int32,  ), weapon_ );
PM_GetOkWeaponForVehicle() = ccall((:PM_GetOkWeaponForVehicle, lib), Int32, (),  );
PM_VehForcedTurning( veh_ ) = ccall((:PM_VehForcedTurning, lib), Void, ( Ptr{bgEntity_t},  ), veh_ );
PM_VehFaceHyperspacePoint( veh_ ) = ccall((:PM_VehFaceHyperspacePoint, lib), Void, ( Ptr{bgEntity_t},  ), veh_ );
PM_VehFaceHyperspacePoint( veh_ ) = ccall((:PM_VehFaceHyperspacePoint, lib), Void, ( Ptr{bgEntity_t},  ), veh_ );
#BG_VehicleAdjustBBoxForOrientation( veh_, origin_, mins_, maxs_, clientNum_, tracemask_, trace_t_, start_, mins_, maxs_, end_, passEntityNum_, contentMask_ ) = ccall((:BG_VehicleAdjustBBoxForOrientation, lib), Void, ( Ptr{Vehicle_t}, vec3_t, vec3_t, vec3_t, Int32, Int32, Ptr{Void}, vec3_t, vec3_t, vec3_t, vec3_t, Int32, Int32,  ), veh_, origin_, mins_, maxs_, clientNum_, tracemask_, trace_t_, start_, mins_, maxs_, end_, passEntityNum_, contentMask_ );
PM_MoveForKata( ucmd_ ) = ccall((:PM_MoveForKata, lib), Void, ( Ptr{usercmd_t},  ), ucmd_ );
PmoveSingle( pmove_ ) = ccall((:PmoveSingle, lib), Void, ( Ptr{pmove_t},  ), pmove_ );
Pmove( pmove_ ) = ccall((:Pmove, lib), Void, ( Ptr{pmove_t},  ), pmove_ );
