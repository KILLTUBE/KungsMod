G_SiegeRegisterWeaponsAndHoldables( team_ ) = ccall((:G_SiegeRegisterWeaponsAndHoldables, lib), Void, ( Int32,  ), team_ );
SiegeSetCompleteData( team_ ) = ccall((:SiegeSetCompleteData, lib), Void, ( Int32,  ), team_ );
InitSiegeMode() = ccall((:InitSiegeMode, lib), Void, (),  );
G_SiegeSetObjectiveComplete( team_, objective_, failIt_ ) = ccall((:G_SiegeSetObjectiveComplete, lib), Void, ( Int32, Int32, qboolean,  ), team_, objective_, failIt_ );
G_SiegeGetCompletionStatus( team_, objective_ ) = ccall((:G_SiegeGetCompletionStatus, lib), qboolean, ( Int32, Int32,  ), team_, objective_ );
UseSiegeTarget( other_, en_, target_ ) = ccall((:UseSiegeTarget, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{Char},  ), other_, en_, target_ );
SiegeBroadcast_OBJECTIVECOMPLETE( team_, client_, objective_ ) = ccall((:SiegeBroadcast_OBJECTIVECOMPLETE, lib), Void, ( Int32, Int32, Int32,  ), team_, client_, objective_ );
SiegeBroadcast_ROUNDOVER( winningteam_, winningclient_ ) = ccall((:SiegeBroadcast_ROUNDOVER, lib), Void, ( Int32, Int32,  ), winningteam_, winningclient_ );
BroadcastObjectiveCompletion( team_, objective_, final_, client_ ) = ccall((:BroadcastObjectiveCompletion, lib), Void, ( Int32, Int32, Int32, Int32,  ), team_, objective_, final_, client_ );
AddSiegeWinningTeamPoints( team_, winner_ ) = ccall((:AddSiegeWinningTeamPoints, lib), Void, ( Int32, Int32,  ), team_, winner_ );
SiegeClearSwitchData() = ccall((:SiegeClearSwitchData, lib), Void, (),  );
SiegeDoTeamAssign() = ccall((:SiegeDoTeamAssign, lib), Void, (),  );
SiegeTeamSwitch( winTeam_, winTime_ ) = ccall((:SiegeTeamSwitch, lib), Void, ( Int32, Int32,  ), winTeam_, winTime_ );
SiegeRoundComplete( winningteam_, winningclient_ ) = ccall((:SiegeRoundComplete, lib), Void, ( Int32, Int32,  ), winningteam_, winningclient_ );
G_ValidateSiegeClassForTeam( ent_, team_ ) = ccall((:G_ValidateSiegeClassForTeam, lib), Void, ( Ptr{gentity_t}, Int32,  ), ent_, team_ );
SetTeamQuick( ent_, team_, doBegin_ ) = ccall((:SetTeamQuick, lib), Void, ( Ptr{gentity_t}, Int32, qboolean,  ), ent_, team_, doBegin_ );
SiegeRespawn( ent_ ) = ccall((:SiegeRespawn, lib), Void, ( Ptr{gentity_t},  ), ent_ );
SiegeBeginRound( entNum_ ) = ccall((:SiegeBeginRound, lib), Void, ( Int32,  ), entNum_ );
SiegeCheckTimers() = ccall((:SiegeCheckTimers, lib), Void, (),  );
SiegeObjectiveCompleted( team_, objective_, final_, client_ ) = ccall((:SiegeObjectiveCompleted, lib), Void, ( Int32, Int32, Int32, Int32,  ), team_, objective_, final_, client_ );
siegeTriggerUse( ent_, other_, activator_ ) = ccall((:siegeTriggerUse, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, other_, activator_ );
SP_info_siege_objective( ent_ ) = ccall((:SP_info_siege_objective, lib), Void, ( Ptr{gentity_t},  ), ent_ );
SiegeIconUse( ent_, other_, activator_ ) = ccall((:SiegeIconUse, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, other_, activator_ );
SP_info_siege_radaricon( ent_ ) = ccall((:SP_info_siege_radaricon, lib), Void, ( Ptr{gentity_t},  ), ent_ );
decompTriggerUse( ent_, other_, activator_ ) = ccall((:decompTriggerUse, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, other_, activator_ );
SP_info_siege_decomplete( ent_ ) = ccall((:SP_info_siege_decomplete, lib), Void, ( Ptr{gentity_t},  ), ent_ );
siegeEndUse( ent_, other_, activator_ ) = ccall((:siegeEndUse, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, other_, activator_ );
SP_target_siege_end( ent_ ) = ccall((:SP_target_siege_end, lib), Void, ( Ptr{gentity_t},  ), ent_ );
SiegeItemRemoveOwner( ent_, carrier_ ) = ccall((:SiegeItemRemoveOwner, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, carrier_ );
SiegeItemRespawnEffect( ent_, newOrg_ ) = ccall((:SiegeItemRespawnEffect, lib), Void, ( Ptr{gentity_t}, vec3_t,  ), ent_, newOrg_ );
SiegeItemRespawnOnOriginalSpot( ent_, carrier_ ) = ccall((:SiegeItemRespawnOnOriginalSpot, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, carrier_ );
SiegeItemThink( ent_ ) = ccall((:SiegeItemThink, lib), Void, ( Ptr{gentity_t},  ), ent_ );
SiegeItemTouch( self_, other_, trace_ ) = ccall((:SiegeItemTouch, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{trace_t},  ), self_, other_, trace_ );
SiegeItemPain( self_, attacker_, damage_ ) = ccall((:SiegeItemPain, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Int32,  ), self_, attacker_, damage_ );
SiegeItemDie( self_, inflictor_, attacker_, damage_, meansOfDeath_ ) = ccall((:SiegeItemDie, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t}, Int32, Int32,  ), self_, inflictor_, attacker_, damage_, meansOfDeath_ );
SiegeItemUse( ent_, other_, activator_ ) = ccall((:SiegeItemUse, lib), Void, ( Ptr{gentity_t}, Ptr{gentity_t}, Ptr{gentity_t},  ), ent_, other_, activator_ );
SP_misc_siege_item( ent_ ) = ccall((:SP_misc_siege_item, lib), Void, ( Ptr{gentity_t},  ), ent_ );
G_SiegeClientExData( msgTarg_ ) = ccall((:G_SiegeClientExData, lib), Void, ( Ptr{gentity_t},  ), msgTarg_ );
