void AddRemap( const char *oldShader, const char *newShader, float timeOffset );
const char *BuildShaderStateConfig();
static int G_FindConfigstringIndex( const char *name, int start, int max, qboolean create );
int G_BoneIndex( const char *name );
int G_ModelIndex( const char *name );
int G_IconIndex( const char *name );
int G_SoundIndex( const char *name );
int G_SoundSetIndex( const char *name );
int G_EffectIndex( const char *name );
int G_BSPIndex( const char *name );
qboolean G_PlayerHasCustomSkeleton( gentity_t *ent );
void G_TeamCommand( team_t team, char *cmd );
gentity_t *G_Find( gentity_t *from, int fieldofs, const char *match );
int G_RadiusList( vec3_t origin, float radius, gentity_t *ignore, qboolean takeDamage, gentity_t *ent_list[MAX_GENTITIES] );
void G_Throw( gentity_t *targ, vec3_t newDir, float push );
void G_FreeFakeClient( gclient_t **cl );
void G_AllocateVehicleObject( Vehicle_t **pVeh );
void G_FreeVehicleObject( Vehicle_t *pVeh );
void G_CreateFakeClient( int entNum, gclient_t **cl );
void G_CleanAllFakeClients();
void G_SetAnim( gentity_t *ent, usercmd_t *ucmd, int setAnimParts, int anim, int setAnimFlags, int blendTime );
gentity_t *G_PickTarget( char *targetname );
void GlobalUse( gentity_t *self, gentity_t *other, gentity_t *activator );
void G_UseTargets2( gentity_t *ent, gentity_t *activator, const char *string );
void G_UseTargets( gentity_t *ent, gentity_t *activator );
float *tv( float x, float y, float z );
char *vtos( const vec3_t v );
void G_SetMovedir( vec3_t angles, vec3_t movedir );
void G_InitGentity( gentity_t *e );
static void G_SpewEntList();
gentity_t *G_Spawn();
qboolean G_EntitiesFree();
void G_SendG2KillQueue();
void G_KillG2Queue( int entNum );
void G_FreeEntity( gentity_t *ed );
gentity_t *G_TempEntity( vec3_t origin, int event );
gentity_t *G_SoundTempEntity( vec3_t origin, int event, int channel );
void G_ScaleNetHealth( gentity_t *self );
void G_KillBox( gentity_t *ent );
void G_AddPredictableEvent( gentity_t *ent, int event, int eventParm );
void G_AddEvent( gentity_t *ent, int event, int eventParm );
gentity_t *G_PlayEffect( int fxID, vec3_t org, vec3_t ang );
gentity_t *G_PlayEffectID( const int fxID, vec3_t org, vec3_t ang );
gentity_t *G_ScreenShake( vec3_t org, gentity_t *target, float intensity, int duration, qboolean global );
void G_MuteSound( int entnum, int channel );
void G_Sound( gentity_t *ent, int channel, int soundIndex );
void G_SoundAtLoc( vec3_t loc, int channel, int soundIndex );
void G_EntitySound( gentity_t *ent, int channel, int soundIndex );
void G_SoundOnEnt( gentity_t *ent, soundChannel_t channel, const char *soundPath );
qboolean ValidUseTarget( gentity_t *ent );
void G_UseDispenserOn( gentity_t *ent, int dispType, gentity_t *target );
int G_CanUseDispOn( gentity_t *ent, int dispType );
qboolean TryHeal( gentity_t *ent, gentity_t *target );
void TryUse( gentity_t *ent );
qboolean G_PointInBounds( vec3_t point, vec3_t mins, vec3_t maxs );
qboolean G_BoxInBounds( vec3_t point, vec3_t mins, vec3_t maxs, vec3_t boundsMins, vec3_t boundsMaxs );
void G_SetAngles( gentity_t *ent, vec3_t angles );
qboolean G_ClearTrace( vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, int ignore, int clipmask );
void G_SetOrigin( gentity_t *ent, vec3_t origin );
qboolean G_CheckInSolid( gentity_t *self, qboolean fix );
int DebugLine( vec3_t start, vec3_t end, int color );
void G_ROFF_NotetrackCallback( gentity_t *cent, const char *notetrack );
void G_SpeechEvent( gentity_t *self, int event );
qboolean G_ExpandPointToBBox( vec3_t point, const vec3_t mins, const vec3_t maxs, int ignore, int clipmask );
float ShortestLineSegBewteen2LineSegs( vec3_t start1, vec3_t end1, vec3_t start2, vec3_t end2, vec3_t close_pnt1, vec3_t close_pnt2 );
