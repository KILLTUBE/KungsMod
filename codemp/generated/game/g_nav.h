void G_Line( vec3_t start, vec3_t end, vec3_t color, float alpha );
void G_Cube( vec3_t mins, vec3_t maxs, vec3_t color, float alpha );
void G_CubeOutline( vec3_t mins, vec3_t maxs, int time, unsigned int color, float alpha );
void G_DrawEdge( vec3_t start, vec3_t end, int type );
void G_DrawNode( vec3_t origin, int type );
void G_DrawCombatPoint( vec3_t origin, int type );
void TAG_ShowTags( int flags );
qboolean FlyingCreature( gentity_t *ent );
void NPC_Blocked( gentity_t *self, gentity_t *blocker );
void NPC_SetMoveGoal( gentity_t *ent, vec3_t point, int radius, qboolean isNavGoal, int combatPoint, gentity_t *targetEnt );
qboolean NAV_HitNavGoal( vec3_t point, vec3_t mins, vec3_t maxs, vec3_t dest, int radius, qboolean flying );
qboolean NAV_ClearPathToPoint( gentity_t *self, vec3_t pmins, vec3_t pmaxs, vec3_t point, int clipmask, int okToHitEntNum );
int NAV_FindClosestWaypointForEnt( gentity_t *ent, int targWp );
int NAV_FindClosestWaypointForPoint( gentity_t *ent, vec3_t point );
int NAV_FindClosestWaypointForPoint2( vec3_t point );
void NAV_ClearBlockedInfo( gentity_t *self );
void NAV_SetBlockedInfo( gentity_t *self, int entId );
int NAV_Steer( gentity_t *self, vec3_t dir, float distance );
qboolean NAV_CheckAhead( gentity_t *self, vec3_t end, trace_t *trace, int clipmask );
static qboolean NAV_TestBypass( gentity_t *self, float yaw, float blocked_dist, vec3_t movedir );
qboolean NAV_Bypass( gentity_t *self, gentity_t *blocker, vec3_t blocked_dir, float blocked_dist, vec3_t movedir );
qboolean NAV_MoveBlocker( gentity_t *self, vec3_t shove_dir );
qboolean NAV_ResolveBlock( gentity_t *self, gentity_t *blocker, vec3_t blocked_dir );
qboolean NAV_TrueCollision( gentity_t *self, gentity_t *blocker, vec3_t movedir, vec3_t blocked_dir );
qboolean NAV_StackedCanyon( gentity_t *self, gentity_t *blocker, vec3_t pathDir );
qboolean NAV_ResolveEntityCollision( gentity_t *self, gentity_t *blocker, vec3_t movedir, vec3_t pathDir );
qboolean NAV_TestForBlocked( gentity_t *self, gentity_t *goal, gentity_t *blocker, float distance, int *flags );
qboolean NAV_AvoidCollision( gentity_t *self, gentity_t *goal, navInfo_t *info );
int NAV_TestBestNode( gentity_t *self, int startID, int endID, qboolean failEdge );
int NAV_GetNearestNode( gentity_t *self, int lastNode );
qboolean NAV_MicroError( vec3_t start, vec3_t end );
int NAV_MoveToGoal( gentity_t *self, navInfo_t *info );
int waypoint_testDirection( vec3_t origin, float yaw, unsigned int minDist );
int waypoint_getRadius( gentity_t *ent );
void SP_waypoint( gentity_t *ent );
void SP_waypoint_small( gentity_t *ent );
void SP_waypoint_navgoal( gentity_t *ent );
void SP_waypoint_navgoal_8( gentity_t *ent );
void SP_waypoint_navgoal_4( gentity_t *ent );
void SP_waypoint_navgoal_2( gentity_t *ent );
void SP_waypoint_navgoal_1( gentity_t *ent );
void Svcmd_Nav_f();
qboolean NAV_WaypointsTooFar( gentity_t *wp1, gentity_t *wp2 );
void NAV_ClearStoredWaypoints();
void NAV_StoreWaypoint( gentity_t *ent );
int NAV_GetStoredWaypoint( char *targetname );
void NAV_CalculatePaths( const char *filename, int checksum );
void NAV_Shutdown();
void NAV_ShowDebugInfo();
void NAV_FindPlayerWaypoint( int clNum );
