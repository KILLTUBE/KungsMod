void G_PlayDoorLoopSound( gentity_t *ent );
void G_PlayDoorSound( gentity_t *ent, int type );
gentity_t *G_TestEntityPosition( gentity_t *ent );
void G_CreateRotationMatrix( vec3_t angles, matrix3_t matrix );
void G_TransposeMatrix( matrix3_t matrix, matrix3_t transpose );
void G_RotatePoint( vec3_t point, matrix3_t matrix );
qboolean G_TryPushingEntity( gentity_t *check, gentity_t *pusher, vec3_t move, vec3_t amove );
qboolean G_MoverPush( gentity_t *pusher, vec3_t move, vec3_t amove, gentity_t **obstacle );
void G_MoverTeam( gentity_t *ent );
void G_RunMover( gentity_t *ent );
void CalcTeamDoorCenter( gentity_t *ent, vec3_t center );
void SetMoverState( gentity_t *ent, moverState_t moverState, int time );
void MatchTeam( gentity_t *teamLeader, int moverState, int time );
void ReturnToPos1( gentity_t *ent );
void Reached_BinaryMover( gentity_t *ent );
void Use_BinaryMover_Go( gentity_t *ent );
void UnLockDoors( const gentity_t *ent );
void LockDoors( const gentity_t *ent );
void Use_BinaryMover( gentity_t *ent, gentity_t *other, gentity_t *activator );
void InitMoverTrData( gentity_t *ent );
void InitMover( gentity_t *ent );
void Blocked_Door( gentity_t *ent, gentity_t *other );
static void Touch_DoorTriggerSpectator( gentity_t *ent, gentity_t *other, trace_t *trace );
void Touch_DoorTrigger( gentity_t *ent, gentity_t *other, trace_t *trace );
void Think_SpawnNewDoorTrigger( gentity_t *ent );
void Think_MatchTeam( gentity_t *ent );
qboolean G_EntIsDoor( int entityNum );
gentity_t *G_FindDoorTrigger( gentity_t *ent );
qboolean G_EntIsUnlockedDoor( int entityNum );
void SP_func_door( gentity_t *ent );
void Touch_Plat( gentity_t *ent, gentity_t *other, trace_t *trace );
void Touch_PlatCenterTrigger( gentity_t *ent, gentity_t *other, trace_t *trace );
void SpawnPlatTrigger( gentity_t *ent );
void SP_func_plat( gentity_t *ent );
void Touch_Button( gentity_t *ent, gentity_t *other, trace_t *trace );
void SP_func_button( gentity_t *ent );
void Think_BeginMoving( gentity_t *ent );
void Reached_Train( gentity_t *ent );
void Think_SetupTrainTargets( gentity_t *ent );
void SP_path_corner( gentity_t *self );
void SP_func_train( gentity_t *self );
void SP_func_static( gentity_t *ent );
void func_static_use( gentity_t *self, gentity_t *other, gentity_t *activator );
void func_rotating_use( gentity_t *self, gentity_t *other, gentity_t *activator );
void SP_func_rotating( gentity_t *ent );
void SP_func_bobbing( gentity_t *ent );
void SP_func_pendulum( gentity_t *ent );
static void CacheChunkEffects( material_t material );
void G_MiscModelExplosion( vec3_t mins, vec3_t maxs, int size, material_t chunkType );
void G_Chunks( int owner, vec3_t origin, const vec3_t normal, const vec3_t mins, const vec3_t maxs, float speed, int numChunks, material_t chunkType, int customChunk, float baseScale );
void funcBBrushDieGo( gentity_t *self );
void funcBBrushDie( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod );
void funcBBrushUse( gentity_t *self, gentity_t *other, gentity_t *activator );
void funcBBrushPain( gentity_t *self, gentity_t *attacker, int damage );
static void InitBBrush( gentity_t *ent );
void funcBBrushTouch( gentity_t *ent, gentity_t *other, trace_t *trace );
void SP_func_breakable( gentity_t *self );
qboolean G_EntIsBreakable( int entityNum );
void GlassDie( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod );
void GlassDie_Old( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod );
void GlassPain( gentity_t *self, gentity_t *attacker, int damage );
void GlassUse( gentity_t *self, gentity_t *other, gentity_t *activator );
void SP_func_glass( gentity_t *ent );
void func_wait_return_solid( gentity_t *self );
void func_usable_think( gentity_t *self );
qboolean G_EntIsRemovableUsable( int entNum );
void func_usable_use( gentity_t *self, gentity_t *other, gentity_t *activator );
void func_usable_pain( gentity_t *self, gentity_t *attacker, int damage );
void func_usable_die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod );
void SP_func_usable( gentity_t *self );
void use_wall( gentity_t *ent, gentity_t *other, gentity_t *activator );
void SP_func_wall( gentity_t *ent );
