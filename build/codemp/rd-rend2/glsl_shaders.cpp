#include "../rd-rend2/tr_local.h"

const char *fallback_bokeh_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_TexCoords = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_bokeh_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"\n"
"#if 0\n"
"	float c[7] = float[7](1.0, 0.9659258263, 0.8660254038, 0.7071067812, 0.5, 0.2588190451, 0.0);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[6]);  color =  texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[5]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[5],  c[1]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[6],  c[0]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[5]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[5], -c[1]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[6], -c[0]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[6]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[5]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[4],  c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[5],  c[1]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[5]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[4], -c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[5], -c[1]);  color += texture(u_TextureMap, tc);\n"
"	\n"
"	out_Color = color * 0.04166667 * u_Color;\n"
"#endif\n"
"\n"
"	float c[5] = float[5](1.0, 0.9238795325, 0.7071067812, 0.3826834324, 0.0);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[4]);  color =  texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[1]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[0]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[1]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[0]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[1]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[1]);  color += texture(u_TextureMap, tc);\n"
"	\n"
"	out_Color = color * 0.0625 * u_Color;\n"
"}\n"
"";
GPUShaderDesc fallback_bokehShaders[] = {
  { GPUSHADER_VERTEX, fallback_bokeh_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_bokeh_fp, 16 },
};
extern const GPUProgramDesc fallback_bokehProgram = { 2, fallback_bokehShaders };

const char *fallback_calclevels4x_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_TexCoords = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_calclevels4x_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"const vec3  LUMINANCE_VECTOR = vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 GetValues(vec2 offset, vec3 current)\n"
"{\n"
"	vec2 tc = var_TexCoords + u_InvTexRes * offset;\n"
"	vec3 minAvgMax = texture(u_TextureMap, tc).rgb;\n"
"\n"
"#ifdef FIRST_PASS\n"
"	float lumi = max(dot(LUMINANCE_VECTOR, minAvgMax), 0.000001);\n"
"	float loglumi = clamp(log2(lumi), -10.0, 10.0);\n"
"	minAvgMax = vec3(loglumi * 0.05 + 0.5);\n"
"#endif\n"
"\n"
"	return vec3(\n"
"		min(current.x, minAvgMax.x),\n"
"		current.y + minAvgMax.y,\n"
"		max(current.z, minAvgMax.z));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 current = vec3(1.0, 0.0, 0.0);\n"
"\n"
"#ifdef FIRST_PASS\n"
"	current = GetValues(vec2( 0.0,  0.0), current);\n"
"#else\n"
"	current = GetValues(vec2(-1.5, -1.5), current);\n"
"	current = GetValues(vec2(-0.5, -1.5), current);\n"
"	current = GetValues(vec2( 0.5, -1.5), current);\n"
"	current = GetValues(vec2( 1.5, -1.5), current);\n"
"	\n"
"	current = GetValues(vec2(-1.5, -0.5), current);\n"
"	current = GetValues(vec2(-0.5, -0.5), current);\n"
"	current = GetValues(vec2( 0.5, -0.5), current);\n"
"	current = GetValues(vec2( 1.5, -0.5), current);\n"
"	\n"
"	current = GetValues(vec2(-1.5,  0.5), current);\n"
"	current = GetValues(vec2(-0.5,  0.5), current);\n"
"	current = GetValues(vec2( 0.5,  0.5), current);\n"
"	current = GetValues(vec2( 1.5,  0.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5,  1.5), current);\n"
"	current = GetValues(vec2(-0.5,  1.5), current);\n"
"	current = GetValues(vec2( 0.5,  1.5), current);\n"
"	current = GetValues(vec2( 1.5,  1.5), current);\n"
"\n"
"	current.y *= 0.0625;\n"
"#endif\n"
"\n"
"	out_Color = vec4(current, 1.0f);\n"
"}\n"
"";
GPUShaderDesc fallback_calclevels4xShaders[] = {
  { GPUSHADER_VERTEX, fallback_calclevels4x_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_calclevels4x_fp, 16 },
};
extern const GPUProgramDesc fallback_calclevels4xProgram = { 2, fallback_calclevels4xShaders };

const char *fallback_depthblur_vp = "in vec4 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"out vec2 var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = attr_Position;\n"
"	var_ScreenTex = attr_TexCoord0.xy;\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
"\n"
"";
const char *fallback_depthblur_fp = "uniform sampler2D u_ScreenImageMap;\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"in vec2 var_ScreenTex;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024, 0.0033);\n"
"float gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);\n"
"//float gauss[3] = float[3](0.60, 0.19, 0.0066);\n"
"#define GAUSS_SIZE 4\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"		float sampleZDivW = texture(depthMap, tex).r;\n"
"		return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"vec4 depthGaussian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar)\n"
"{\n"
"	float scale = 1.0 / 256.0;\n"
"\n"
"#if defined(USE_HORIZONTAL_BLUR)\n"
"    vec2 direction = vec2(1.0, 0.0) * scale;\n"
"#else // if defined(USE_VERTICAL_BLUR)\n"
"	vec2 direction = vec2(0.0, 1.0) * scale;\n"
"#endif\n"
"	\n"
"	float depthCenter = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"	vec2 centerSlope = vec2(dFdx(depthCenter), dFdy(depthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"		\n"
"	vec4 result = texture(imageMap, tex) * gauss[0];\n"
"	float total = gauss[0];\n"
"\n"
"	int i, j;\n"
"	for (i = 0; i < 2; i++)\n"
"	{\n"
"		for (j = 1; j < GAUSS_SIZE; j++)\n"
"		{\n"
"			vec2 offset = direction * j;\n"
"			float depthSample = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"			float depthExpected = depthCenter + dot(centerSlope, offset);\n"
"			if(abs(depthSample - depthExpected) < 5.0)\n"
"			{\n"
"				result += texture(imageMap, tex + offset) * gauss[j];\n"
"				total += gauss[j];\n"
"			}\n"
"		}\n"
"		\n"
"		direction = -direction;\n"
"	}	\n"
"		\n"
"	return result / total;\n"
"}\n"
"\n"
"void main()\n"
"{		\n"
"	out_Color = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);\n"
"}\n"
"";
GPUShaderDesc fallback_depthblurShaders[] = {
  { GPUSHADER_VERTEX, fallback_depthblur_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_depthblur_fp, 16 },
};
extern const GPUProgramDesc fallback_depthblurProgram = { 2, fallback_depthblurShaders };

const char *fallback_dglow_downsample_vp = "out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	const vec2 positions[] = vec2[3](\n"
"		vec2(-1.0f, -1.0f),\n"
"		vec2(-1.0f,  3.0f),\n"
"		vec2( 3.0f, -1.0f)\n"
"	);\n"
"\n"
"	const vec2 texcoords[] = vec2[3](\n"
"		vec2( 0.0f,  1.0f),\n"
"		vec2( 0.0f, -1.0f),\n"
"		vec2( 2.0f,  1.0f)\n"
"	);\n"
"\n"
"	gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n"
"	var_TexCoords = texcoords[gl_VertexID];\n"
"}\n"
"\n"
"";
const char *fallback_dglow_downsample_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	// Based on \"Next Generation Post Processing in Call of Duty: Advanced Warfare\":\n"
"	// http://advances.realtimerendering.com/s2014/index.html\n"
"	vec4 color = vec4(0.0);\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-2.0, -2.0)));\n"
"	color += 0.5 * 0.25 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 0.0, -2.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 2.0, -2.0)));\n"
"	color += 0.25 * 0.5 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-1.0, -1.0)));\n"
"	color += 0.25 * 0.5 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 1.0, -1.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-2.0,  0.0)));\n"
"	color += 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 0.0,  0.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 2.0, -2.0)));\n"
"	color += 0.25 * 0.5 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-1.0,  1.0)));\n"
"	color += 0.25 * 0.5 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 1.0,  1.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-2.0,  2.0)));\n"
"	color += 0.5 * 0.25 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 0.0,  2.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 2.0,  2.0)));\n"
"\n"
"	out_Color = color;\n"
"}";
GPUShaderDesc fallback_dglow_downsampleShaders[] = {
  { GPUSHADER_VERTEX, fallback_dglow_downsample_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_dglow_downsample_fp, 23 },
};
extern const GPUProgramDesc fallback_dglow_downsampleProgram = { 2, fallback_dglow_downsampleShaders };

const char *fallback_dglow_upsample_vp = "out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	const vec2 positions[] = vec2[3](\n"
"		vec2(-1.0f, -1.0f),\n"
"		vec2(-1.0f,  3.0f),\n"
"		vec2( 3.0f, -1.0f)\n"
"	);\n"
"\n"
"	const vec2 texcoords[] = vec2[3](\n"
"		vec2( 0.0f,  1.0f),\n"
"		vec2( 0.0f, -1.0f),\n"
"		vec2( 2.0f,  1.0f)\n"
"	);\n"
"\n"
"	gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n"
"	var_TexCoords = texcoords[gl_VertexID];\n"
"}\n"
"\n"
"";
const char *fallback_dglow_upsample_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	// Based on \"Next Generation Post Processing in Call of Duty: Advanced Warfare\":\n"
"	// http://advances.realtimerendering.com/s2014/index.html\n"
"	vec4 color = vec4(0.0);\n"
"	color += 0.0625 * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2(-1.0, -1.0));\n"
"	color += 0.125  * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 0.0, -1.0));\n"
"	color += 0.0625 * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 1.0, -1.0));\n"
"	color += 0.125  * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2(-1.0,  0.0));\n"
"	color += 0.25   * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 0.0,  0.0));\n"
"	color += 0.125  * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 1.0,  0.0));\n"
"	color += 0.0625 * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2(-1.0,  1.0));\n"
"	color += 0.125  * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 0.0,  1.0));\n"
"	color += 0.0625 * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 1.0,  1.0));\n"
"\n"
"	out_Color = color;\n"
"}";
GPUShaderDesc fallback_dglow_upsampleShaders[] = {
  { GPUSHADER_VERTEX, fallback_dglow_upsample_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_dglow_upsample_fp, 23 },
};
extern const GPUProgramDesc fallback_dglow_upsampleProgram = { 2, fallback_dglow_upsampleShaders };

const char *fallback_dlight_vp = "in vec3 attr_Position;\n"
"in vec2 attr_TexCoord0;\n"
"in vec3 attr_Normal;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int u_DeformType;\n"
"uniform int u_DeformFunc;\n"
"uniform float u_DeformParams[7];\n"
"uniform float u_Time;\n"
"#endif\n"
"\n"
"uniform vec4 u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"\n"
"uniform mat4 u_ModelMatrix;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec3 var_Normal;\n"
"out vec4 var_LightDirAndRadiusSq;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"float GetNoiseValue( float x, float y, float z, float t )\n"
"{\n"
"	// Variation on the 'one-liner random function'.\n"
"	// Not sure if this is still 'correctly' random\n"
"	return fract( sin( dot(\n"
"		vec4( x, y, z, t ),\n"
"		vec4( 12.9898, 78.233, 12.9898, 78.233 )\n"
"	)) * 43758.5453 );\n"
"}\n"
"\n"
"float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )\n"
"{\n"
"	float value = phase + time * frequency;\n"
"\n"
"	switch ( func )\n"
"	{\n"
"		case WF_SIN:\n"
"			return sin(value * 2.0 * M_PI);\n"
"		case WF_SQUARE:\n"
"			return sign(0.5 - fract(value));\n"
"		case WF_TRIANGLE:\n"
"			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"		case WF_SAWTOOTH:\n"
"			return fract(value);\n"
"		case WF_INVERSE_SAWTOOTH:\n"
"			return 1.0 - fract(value);\n"
"		default:\n"
"			return 0.0;\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"	switch ( u_DeformType )\n"
"	{\n"
"		default:\n"
"		{\n"
"			return pos;\n"
"		}\n"
"\n"
"		case DEFORM_BULGE:\n"
"		{\n"
"			float bulgeHeight = u_DeformParams[1]; // amplitude\n"
"			float bulgeWidth = u_DeformParams[2]; // phase\n"
"			float bulgeSpeed = u_DeformParams[3]; // frequency\n"
"\n"
"			float scale = CalculateDeformScale( WF_SIN, u_Time, bulgeWidth * st.x, bulgeSpeed );\n"
"\n"
"			return pos + normal * scale * bulgeHeight;\n"
"		}\n"
"\n"
"		case DEFORM_WAVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			float spread = u_DeformParams[4];\n"
"\n"
"			float offset = dot( pos.xyz, vec3( spread ) );\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase + offset, frequency );\n"
"\n"
"			return pos + normal * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_MOVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			vec3 direction = vec3( u_DeformParams[4], u_DeformParams[5], u_DeformParams[6] );\n"
"\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase, frequency );\n"
"\n"
"			return pos + direction * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_PROJECTION_SHADOW:\n"
"		{\n"
"			vec3 ground = vec3(\n"
"				u_DeformParams[0],\n"
"				u_DeformParams[1],\n"
"				u_DeformParams[2]);\n"
"			float groundDist = u_DeformParams[3];\n"
"			vec3 lightDir = vec3(\n"
"				u_DeformParams[4],\n"
"				u_DeformParams[5],\n"
"				u_DeformParams[6]);\n"
"\n"
"			float d = dot( lightDir, ground );\n"
"\n"
"			lightDir = lightDir * max( 0.5 - d, 0.0 ) + ground;\n"
"			d = 1.0 / dot( lightDir, ground );\n"
"\n"
"			vec3 lightPos = lightDir * d;\n"
"\n"
"			return pos - lightPos * dot( pos, ground ) + groundDist;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformNormal( const in vec3 position, const in vec3 normal )\n"
"{\n"
"	if ( u_DeformType != DEFORM_NORMALS )\n"
"	{\n"
"		return normal;\n"
"	}\n"
"\n"
"	float amplitude = u_DeformParams[1];\n"
"	float frequency = u_DeformParams[3];\n"
"\n"
"	vec3 outNormal = normal;\n"
"	const float scale = 0.98;\n"
"	\n"
"	outNormal.x += amplitude * GetNoiseValue(\n"
"		position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.y += amplitude * GetNoiseValue(\n"
"		100.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.z += amplitude * GetNoiseValue(\n"
"		200.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	return outNormal;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	vec3 position = attr_Position;\n"
"	vec3 normal = normalize(attr_Normal * 2.0 - vec3(1.0));\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"	position = DeformPosition(position, normal, attr_TexCoord0.st);\n"
"	normal = DeformNormal(position, normal);\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"	\n"
"	vec3 positionWS = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"	vec3 L = u_LightOrigin.xyz - positionWS;\n"
"	L = (u_ModelMatrix * vec4(L, 0.0)).xyz;\n"
"\n"
"	var_Normal = normalize((u_ModelMatrix * vec4(normal, 0.0)).xyz);\n"
"	var_LightDirAndRadiusSq = vec4(L, u_LightRadius * u_LightRadius);\n"
"}\n"
"\n"
"";
const char *fallback_dlight_fp = "uniform vec3 u_DirectedLight;\n"
"\n"
"in vec3 var_Normal;\n"
"in vec4 var_LightDirAndRadiusSq;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"float CalcLightAttenuation(float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) + 1.0;\n"
"	return clamp(attenuation, 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float lightDistSq = dot(var_LightDirAndRadiusSq.xyz, var_LightDirAndRadiusSq.xyz);\n"
"	vec3  N           = normalize(var_Normal);\n"
"	vec3  L           = var_LightDirAndRadiusSq.xyz / sqrt(lightDistSq);\n"
"\n"
"	float attenuation = CalcLightAttenuation(var_LightDirAndRadiusSq.w / lightDistSq);\n"
"	float NL          = clamp(dot(N, L), 0.0, 1.0);\n"
"\n"
"	out_Color = vec4(NL * attenuation * u_DirectedLight, 1.0);\n"
"}\n"
"";
GPUShaderDesc fallback_dlightShaders[] = {
  { GPUSHADER_VERTEX, fallback_dlight_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_dlight_fp, 181 },
};
extern const GPUProgramDesc fallback_dlightProgram = { 2, fallback_dlightShaders };

const char *fallback_down4x_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_TexCoords = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_down4x_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"	\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-1.5, -1.5);  color  = texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-0.5, -1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 0.5, -1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 1.5, -1.5);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-1.5, -0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-0.5, -0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 0.5, -0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 1.5, -0.5); color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-1.5,  0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-0.5,  0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 0.5,  0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 1.5,  0.5); color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-1.5,  1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-0.5,  1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 0.5,  1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 1.5,  1.5);  color += texture(u_TextureMap, tc);\n"
"	\n"
"	color *= 0.0625;\n"
"	\n"
"	out_Color = color;\n"
"}\n"
"";
GPUShaderDesc fallback_down4xShaders[] = {
  { GPUSHADER_VERTEX, fallback_down4x_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_down4x_fp, 17 },
};
extern const GPUProgramDesc fallback_down4xProgram = { 2, fallback_down4xShaders };

const char *fallback_fogpass_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"\n"
"in vec2 attr_TexCoord0;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"in vec3 attr_Position2;\n"
"in vec3 attr_Normal2;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"in uvec4 attr_BoneIndexes;\n"
"in vec4 attr_BoneWeights;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int u_DeformType;\n"
"uniform int u_DeformFunc;\n"
"uniform float u_DeformParams[7];\n"
"#endif\n"
"\n"
"uniform float u_Time;\n"
"uniform mat4 u_ModelMatrix;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float u_VertexLerp;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"uniform mat4x3 u_BoneMatrices[20];\n"
"#endif\n"
"\n"
"uniform vec4 u_Color;\n"
"\n"
"out vec3 var_WSPosition;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"float GetNoiseValue( float x, float y, float z, float t )\n"
"{\n"
"	// Variation on the 'one-liner random function'.\n"
"	// Not sure if this is still 'correctly' random\n"
"	return fract( sin( dot(\n"
"		vec4( x, y, z, t ),\n"
"		vec4( 12.9898, 78.233, 12.9898, 78.233 )\n"
"	)) * 43758.5453 );\n"
"}\n"
"\n"
"float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )\n"
"{\n"
"	float value = phase + time * frequency;\n"
"\n"
"	switch ( func )\n"
"	{\n"
"		case WF_SIN:\n"
"			return sin(value * 2.0 * M_PI);\n"
"		case WF_SQUARE:\n"
"			return sign(0.5 - fract(value));\n"
"		case WF_TRIANGLE:\n"
"			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"		case WF_SAWTOOTH:\n"
"			return fract(value);\n"
"		case WF_INVERSE_SAWTOOTH:\n"
"			return 1.0 - fract(value);\n"
"		default:\n"
"			return 0.0;\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"	switch ( u_DeformType )\n"
"	{\n"
"		default:\n"
"		{\n"
"			return pos;\n"
"		}\n"
"\n"
"		case DEFORM_BULGE:\n"
"		{\n"
"			float bulgeHeight = u_DeformParams[1]; // amplitude\n"
"			float bulgeWidth = u_DeformParams[2]; // phase\n"
"			float bulgeSpeed = u_DeformParams[3]; // frequency\n"
"\n"
"			float scale = CalculateDeformScale( WF_SIN, u_Time, bulgeWidth * st.x, bulgeSpeed );\n"
"\n"
"			return pos + normal * scale * bulgeHeight;\n"
"		}\n"
"\n"
"		case DEFORM_WAVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			float spread = u_DeformParams[4];\n"
"\n"
"			float offset = dot( pos.xyz, vec3( spread ) );\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase + offset, frequency );\n"
"\n"
"			return pos + normal * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_MOVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			vec3 direction = vec3( u_DeformParams[4], u_DeformParams[5], u_DeformParams[6] );\n"
"\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase, frequency );\n"
"\n"
"			return pos + direction * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_PROJECTION_SHADOW:\n"
"		{\n"
"			vec3 ground = vec3(\n"
"				u_DeformParams[0],\n"
"				u_DeformParams[1],\n"
"				u_DeformParams[2]);\n"
"			float groundDist = u_DeformParams[3];\n"
"			vec3 lightDir = vec3(\n"
"				u_DeformParams[4],\n"
"				u_DeformParams[5],\n"
"				u_DeformParams[6]);\n"
"\n"
"			float d = dot( lightDir, ground );\n"
"\n"
"			lightDir = lightDir * max( 0.5 - d, 0.0 ) + ground;\n"
"			d = 1.0 / dot( lightDir, ground );\n"
"\n"
"			vec3 lightPos = lightDir * d;\n"
"\n"
"			return pos - lightPos * dot( pos, ground ) + groundDist;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformNormal( const in vec3 position, const in vec3 normal )\n"
"{\n"
"	if ( u_DeformType != DEFORM_NORMALS )\n"
"	{\n"
"		return normal;\n"
"	}\n"
"\n"
"	float amplitude = u_DeformParams[1];\n"
"	float frequency = u_DeformParams[3];\n"
"\n"
"	vec3 outNormal = normal;\n"
"	const float scale = 0.98;\n"
"	\n"
"	outNormal.x += amplitude * GetNoiseValue(\n"
"		position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.y += amplitude * GetNoiseValue(\n"
"		100.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.z += amplitude * GetNoiseValue(\n"
"		200.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	return outNormal;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"	vec3 position = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"	vec3 normal   = mix(attr_Normal,   attr_Normal2,   u_VertexLerp);\n"
"	normal = normalize(normal - vec3(0.5));\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"	vec4 position4 = vec4(0.0);\n"
"	vec4 normal4 = vec4(0.0);\n"
"	vec4 originalPosition = vec4(attr_Position, 1.0);\n"
"	vec4 originalNormal = vec4(attr_Normal - vec3 (0.5), 0.0);\n"
"\n"
"	for (int i = 0; i < 4; i++)\n"
"	{\n"
"		uint boneIndex = attr_BoneIndexes[i];\n"
"\n"
"		mat4 boneMatrix = mat4(\n"
"			vec4(u_BoneMatrices[boneIndex][0], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][1], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][2], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][3], 1.0)\n"
"		);\n"
"\n"
"		position4 += (boneMatrix * originalPosition) * attr_BoneWeights[i];\n"
"		normal4 += (boneMatrix * originalNormal) * attr_BoneWeights[i];\n"
"	}\n"
"\n"
"	vec3 position = position4.xyz;\n"
"	vec3 normal = normalize(normal4.xyz);\n"
"#else\n"
"	vec3 position = attr_Position;\n"
"	vec3 normal   = attr_Normal * 2.0 - vec3(1.0);\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"	position = DeformPosition(position, normal, attr_TexCoord0.st);\n"
"	normal = DeformNormal( position, normal );\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"	var_WSPosition = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"}\n"
"\n"
"";
const char *fallback_fogpass_fp = "uniform vec4 u_Color;\n"
"#if defined(USE_ALPHA_TEST)\n"
"uniform int u_AlphaTestType;\n"
"#endif\n"
"\n"
"uniform vec4 u_FogPlane;\n"
"uniform float u_FogDepthToOpaque;\n"
"uniform bool u_FogHasPlane;\n"
"uniform vec3 u_ViewOrigin;\n"
"in vec3 var_WSPosition;\n"
"\n"
"out vec4 out_Color;\n"
"out vec4 out_Glow;\n"
"\n"
"float CalcFog(in vec3 viewOrigin, in vec3 position, in vec4 fogPlane, in float depthToOpaque, in bool hasPlane)\n"
"{\n"
"	// line: x = o + tv\n"
"	// plane: (x . n) + d = 0\n"
"	// intersects: dot(o + tv, n) + d = 0\n"
"	//             dot(o + tv, n) = -d\n"
"	//             dot(o, n) + t*dot(n, v) = -d\n"
"	//             t = -(d + dot(o, n)) / dot(n, v)\n"
"	vec3 V = position - viewOrigin;\n"
"\n"
"	// fogPlane is inverted in tr_bsp for some reason.\n"
"	float t = -(fogPlane.w + dot(viewOrigin, -fogPlane.xyz)) / dot(V, -fogPlane.xyz);\n"
"\n"
"	bool inFog = ((dot(viewOrigin, fogPlane.xyz) - fogPlane.w) >= 0.0) || !hasPlane;\n"
"	bool intersects = (t > 0.0 && t <= 1.0);\n"
"\n"
"	// this is valid only when t > 0.0. When t < 0.0, then intersection point is behind\n"
"	// the camera, meaning we're facing away from the fog plane, which probably means\n"
"	// we're inside the fog volume.\n"
"	vec3 intersectsAt = viewOrigin + t*V;\n"
"\n"
"	float distToVertexFromIntersection = distance(intersectsAt, position);\n"
"	float distToVertexFromViewOrigin = distance(viewOrigin, position);\n"
"\n"
"	float distToVertex = mix(distToVertexFromViewOrigin,\n"
"							 distToVertexFromIntersection,\n"
"							 !inFog && intersects);\n"
"\n"
"	float z = depthToOpaque * distToVertex;\n"
"	return 1.0 - clamp(exp(-(z * z)), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float fog = CalcFog(u_ViewOrigin, var_WSPosition, u_FogPlane, u_FogDepthToOpaque, u_FogHasPlane);\n"
"	out_Color.rgb = u_Color.rgb;\n"
"	out_Color.a = sqrt(clamp(fog, 0.0, 1.0));\n"
"\n"
"#if defined(USE_ALPHA_TEST)\n"
"	if (u_AlphaTestType == ALPHA_TEST_GT0)\n"
"	{\n"
"		if (out_Color.a == 0.0)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTestType == ALPHA_TEST_LT128)\n"
"	{\n"
"		if (out_Color.a >= 0.5)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTestType == ALPHA_TEST_GE128)\n"
"	{\n"
"		if (out_Color.a < 0.5)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTestType == ALPHA_TEST_GE192)\n"
"	{\n"
"		if (out_Color.a < 0.75)\n"
"			discard;\n"
"	}\n"
"#endif\n"
"\n"
"#if defined(USE_GLOW_BUFFER)\n"
"	out_Glow = out_Color;\n"
"#else\n"
"	out_Glow = vec4(0.0);\n"
"#endif\n"
"}\n"
"";
GPUShaderDesc fallback_fogpassShaders[] = {
  { GPUSHADER_VERTEX, fallback_fogpass_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_fogpass_fp, 218 },
};
extern const GPUProgramDesc fallback_fogpassProgram = { 2, fallback_fogpassShaders };

const char *fallback_gaussian_blur_vp = "out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	const vec2 positions[4] = vec2[](\n"
"		vec2 (-1.0, -1.0),\n"
"		vec2 (1.0, -1.0),\n"
"		vec2 (1.0, 1.0),\n"
"		vec2 (-1.0, 1.0)\n"
"	);\n"
"\n"
"	const vec2 texcoords[4] = vec2[](\n"
"		vec2 (0.0, 0.0),\n"
"		vec2 (1.0, 0.0),\n"
"		vec2 (1.0, 1.0),\n"
"		vec2 (0.0, 1.0)\n"
"	);\n"
"\n"
"	gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n"
"	var_TexCoords = texcoords[gl_VertexID];\n"
"}\n"
"\n"
"";
const char *fallback_gaussian_blur_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec4  u_Color;\n"
"uniform vec2  u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"#define NUM_TAPS 3\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = vec4 (0.0);\n"
"\n"
"#if NUM_TAPS == 7\n"
"	const float weights[] = float[4](1.0 / 64.0, 6.0 / 64.0, 15.0 / 64.0, 20.0 / 64.0);\n"
"\n"
"#if defined(BLUR_X)\n"
"	color += texture (u_TextureMap, vec2 (-3.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"	color += texture (u_TextureMap, vec2 (-2.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 (-1.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[2];\n"
"	color += texture (u_TextureMap, vec2 ( 0.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[3];\n"
"	color += texture (u_TextureMap, vec2 ( 1.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[2];\n"
"	color += texture (u_TextureMap, vec2 ( 2.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 ( 3.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"#else\n"
"	color += texture (u_TextureMap, vec2 (0.0, -3.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"	color += texture (u_TextureMap, vec2 (0.0, -2.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 (0.0, -1.0) * u_InvTexRes + var_TexCoords) * weights[2];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  0.0) * u_InvTexRes + var_TexCoords) * weights[3];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  1.0) * u_InvTexRes + var_TexCoords) * weights[2];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  2.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  3.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"#endif\n"
"#elif NUM_TAPS == 3\n"
"	const float weights[] = float[2](0.25, 0.5);\n"
"\n"
"#if defined(BLUR_X)\n"
"	color += texture (u_TextureMap, vec2 (-1.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"	color += texture (u_TextureMap, vec2 ( 0.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 ( 1.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"#else\n"
"	color += texture (u_TextureMap, vec2 (0.0, -1.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  0.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  1.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"#endif\n"
"#endif\n"
"\n"
"	out_Color = color * u_Color;\n"
"}";
GPUShaderDesc fallback_gaussian_blurShaders[] = {
  { GPUSHADER_VERTEX, fallback_gaussian_blur_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_gaussian_blur_fp, 25 },
};
extern const GPUProgramDesc fallback_gaussian_blurProgram = { 2, fallback_gaussian_blurShaders };

const char *fallback_generic_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"in vec3 attr_Position2;\n"
"in vec3 attr_Normal2;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"in uvec4 attr_BoneIndexes;\n"
"in vec4 attr_BoneWeights;\n"
"#endif\n"
"\n"
"in vec4 attr_Color;\n"
"in vec2 attr_TexCoord0;\n"
"\n"
"#if defined(USE_TCGEN)\n"
"in vec2 attr_TexCoord1;\n"
"#endif\n"
"\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_RGBAGEN)\n"
"uniform vec3 u_LocalViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int u_DeformType;\n"
"uniform int u_DeformFunc;\n"
"uniform float u_DeformParams[7];\n"
"uniform float u_Time;\n"
"#endif\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform mat4 u_ModelMatrix;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"uniform vec3 u_ViewForward;\n"
"uniform float u_FXVolumetricBase;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_AmbientLight;\n"
"uniform vec3 u_DirectedLight;\n"
"uniform vec3 u_ModelLightDir;\n"
"uniform float u_PortalRange;\n"
"#endif\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float u_VertexLerp;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"uniform mat4x3 u_BoneMatrices[20];\n"
"#endif\n"
"\n"
"out vec2 var_DiffuseTex;\n"
"out vec4 var_Color;\n"
"#if defined(USE_FOG)\n"
"out vec3 var_WSPosition;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"float GetNoiseValue( float x, float y, float z, float t )\n"
"{\n"
"	// Variation on the 'one-liner random function'.\n"
"	// Not sure if this is still 'correctly' random\n"
"	return fract( sin( dot(\n"
"		vec4( x, y, z, t ),\n"
"		vec4( 12.9898, 78.233, 12.9898, 78.233 )\n"
"	)) * 43758.5453 );\n"
"}\n"
"\n"
"float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )\n"
"{\n"
"	float value = phase + time * frequency;\n"
"\n"
"	switch ( func )\n"
"	{\n"
"		case WF_SIN:\n"
"			return sin(value * 2.0 * M_PI);\n"
"		case WF_SQUARE:\n"
"			return sign(0.5 - fract(value));\n"
"		case WF_TRIANGLE:\n"
"			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"		case WF_SAWTOOTH:\n"
"			return fract(value);\n"
"		case WF_INVERSE_SAWTOOTH:\n"
"			return 1.0 - fract(value);\n"
"		default:\n"
"			return 0.0;\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"	switch ( u_DeformType )\n"
"	{\n"
"		default:\n"
"		{\n"
"			return pos;\n"
"		}\n"
"\n"
"		case DEFORM_BULGE:\n"
"		{\n"
"			float bulgeHeight = u_DeformParams[1]; // amplitude\n"
"			float bulgeWidth = u_DeformParams[2]; // phase\n"
"			float bulgeSpeed = u_DeformParams[3]; // frequency\n"
"\n"
"			float scale = CalculateDeformScale( WF_SIN, u_Time, bulgeWidth * st.x, bulgeSpeed );\n"
"\n"
"			return pos + normal * scale * bulgeHeight;\n"
"		}\n"
"\n"
"		case DEFORM_WAVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			float spread = u_DeformParams[4];\n"
"\n"
"			float offset = dot( pos.xyz, vec3( spread ) );\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase + offset, frequency );\n"
"\n"
"			return pos + normal * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_MOVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			vec3 direction = vec3( u_DeformParams[4], u_DeformParams[5], u_DeformParams[6] );\n"
"\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase, frequency );\n"
"\n"
"			return pos + direction * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_PROJECTION_SHADOW:\n"
"		{\n"
"			vec3 ground = vec3(\n"
"				u_DeformParams[0],\n"
"				u_DeformParams[1],\n"
"				u_DeformParams[2]);\n"
"			float groundDist = u_DeformParams[3];\n"
"			vec3 lightDir = vec3(\n"
"				u_DeformParams[4],\n"
"				u_DeformParams[5],\n"
"				u_DeformParams[6]);\n"
"\n"
"			float d = dot( lightDir, ground );\n"
"\n"
"			lightDir = lightDir * max( 0.5 - d, 0.0 ) + ground;\n"
"			d = 1.0 / dot( lightDir, ground );\n"
"\n"
"			vec3 lightPos = lightDir * d;\n"
"\n"
"			return pos - lightPos * dot( pos, ground ) + groundDist;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformNormal( const in vec3 position, const in vec3 normal )\n"
"{\n"
"	if ( u_DeformType != DEFORM_NORMALS )\n"
"	{\n"
"		return normal;\n"
"	}\n"
"\n"
"	float amplitude = u_DeformParams[1];\n"
"	float frequency = u_DeformParams[3];\n"
"\n"
"	vec3 outNormal = normal;\n"
"	const float scale = 0.98;\n"
"	\n"
"	outNormal.x += amplitude * GetNoiseValue(\n"
"		position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.y += amplitude * GetNoiseValue(\n"
"		100.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.z += amplitude * GetNoiseValue(\n"
"		200.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	return outNormal;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"	vec2 tex = attr_TexCoord0.st;\n"
"\n"
"	if (TCGen >= TCGEN_LIGHTMAP && TCGen <= TCGEN_LIGHTMAP3)\n"
"	{\n"
"		tex = attr_TexCoord1.st;\n"
"	}\n"
"	else if (TCGen == TCGEN_ENVIRONMENT_MAPPED)\n"
"	{\n"
"		vec3 viewer = normalize(u_LocalViewOrigin - position);\n"
"		vec2 ref = reflect(viewer, normal).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if (TCGen == TCGEN_VECTOR)\n"
"	{\n"
"		tex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"	}\n"
"	\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"	st2.x = st.x * texMatrix.x + (st.y * texMatrix.z + offTurb.x);\n"
"	st2.y = st.x * texMatrix.y + (st.y * texMatrix.w + offTurb.y);\n"
"\n"
"	vec2 offsetPos = vec2(position.x + position.z, position.y);\n"
"	\n"
"	vec2 texOffset = sin(offsetPos * (2.0 * M_PI / 1024.0) + vec2(phase));\n"
"	\n"
"	return st2 + texOffset * amplitude;	\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * attr_Color + u_BaseColor;\n"
"	\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"	\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"	{\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"		\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"	else if (u_AlphaGen == AGEN_PORTAL)\n"
"	{\n"
"		color.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"	}\n"
"	\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"	vec3 position  = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"	vec3 normal    = mix(attr_Normal,   attr_Normal2,   u_VertexLerp);\n"
"	normal = normalize(normal - vec3(0.5));\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"	vec4 position4 = vec4(0.0);\n"
"	vec4 normal4 = vec4(0.0);\n"
"	vec4 originalPosition = vec4(attr_Position, 1.0);\n"
"	vec4 originalNormal = vec4(attr_Normal - vec3 (0.5), 0.0);\n"
"\n"
"	for (int i = 0; i < 4; i++)\n"
"	{\n"
"		uint boneIndex = attr_BoneIndexes[i];\n"
"\n"
"		mat4 boneMatrix = mat4(\n"
"			vec4(u_BoneMatrices[boneIndex][0], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][1], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][2], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][3], 1.0)\n"
"		);\n"
"\n"
"		position4 += (boneMatrix * originalPosition) * attr_BoneWeights[i];\n"
"		normal4 += (boneMatrix * originalNormal) * attr_BoneWeights[i];\n"
"	}\n"
"\n"
"	vec3 position = position4.xyz;\n"
"	vec3 normal = normalize(normal4.xyz);\n"
"#else\n"
"	vec3 position  = attr_Position;\n"
"	vec3 normal    = attr_Normal * 2.0 - vec3(1.0);\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"	position = DeformPosition(position, normal, attr_TexCoord0.st);\n"
"	normal = DeformNormal( position, normal );\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 tex = GenTexCoords(u_TCGen0, position, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"	vec2 tex = attr_TexCoord0.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	var_DiffuseTex = ModTexCoords(tex, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"    var_DiffuseTex = tex;\n"
"#endif\n"
"\n"
"	if ( u_FXVolumetricBase >= 0.0 )\n"
"	{\n"
"		vec3 viewForward = u_ViewForward;\n"
"		float d = clamp(dot(normalize(viewForward), normalize(normal)), 0.0, 1.0);\n"
"		d = d * d;\n"
"		d = d * d;\n"
"\n"
"		var_Color = vec4(u_FXVolumetricBase * (1.0 - d));\n"
"	}\n"
"	else\n"
"	{\n"
"#if defined(USE_RGBAGEN)\n"
"		var_Color = CalcColor(position, normal);\n"
"#else\n"
"		var_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"#endif\n"
"	}\n"
"\n"
"#if defined(USE_FOG)\n"
"	var_WSPosition = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"#endif\n"
"}\n"
"\n"
"\n"
"";
const char *fallback_generic_fp = "uniform sampler2D u_DiffuseMap;\n"
"#if defined(USE_ALPHA_TEST)\n"
"uniform int u_AlphaTestType;\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"uniform vec4 u_FogPlane;\n"
"uniform float u_FogDepthToOpaque;\n"
"uniform bool u_FogHasPlane;\n"
"uniform vec3 u_ViewOrigin;\n"
"uniform vec4 u_FogColorMask;\n"
"#endif\n"
"\n"
"in vec2 var_DiffuseTex;\n"
"in vec4 var_Color;\n"
"#if defined(USE_FOG)\n"
"in vec3 var_WSPosition;\n"
"#endif\n"
"\n"
"out vec4 out_Color;\n"
"out vec4 out_Glow;\n"
"\n"
"\n"
"#if defined(USE_FOG)\n"
"float CalcFog(in vec3 viewOrigin, in vec3 position, in vec4 fogPlane, in float depthToOpaque, in bool hasPlane)\n"
"{\n"
"	// line: x = o + tv\n"
"	// plane: (x . n) + d = 0\n"
"	// intersects: dot(o + tv, n) + d = 0\n"
"	//             dot(o + tv, n) = -d\n"
"	//             dot(o, n) + t*dot(n, v) = -d\n"
"	//             t = -(d + dot(o, n)) / dot(n, v)\n"
"	vec3 V = position - viewOrigin;\n"
"\n"
"	// fogPlane is inverted in tr_bsp for some reason.\n"
"	float t = -(fogPlane.w + dot(viewOrigin, -fogPlane.xyz)) / dot(V, -fogPlane.xyz);\n"
"\n"
"	bool inFog = ((dot(viewOrigin, fogPlane.xyz) - fogPlane.w) >= 0.0) || !hasPlane;\n"
"	bool intersects = (t > 0.0 && t <= 1.0);\n"
"\n"
"	// this is valid only when t > 0.0. When t < 0.0, then intersection point is behind\n"
"	// the camera, meaning we're facing away from the fog plane, which probably means\n"
"	// we're inside the fog volume.\n"
"	vec3 intersectsAt = viewOrigin + t*V;\n"
"\n"
"	float distToVertexFromIntersection = distance(intersectsAt, position);\n"
"	float distToVertexFromViewOrigin = distance(viewOrigin, position);\n"
"\n"
"	float distToVertex = mix(distToVertexFromViewOrigin,\n"
"							 distToVertexFromIntersection,\n"
"							 !inFog && intersects);\n"
"\n"
"	return min(distToVertex / depthToOpaque, 1.0);\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color  = texture(u_DiffuseMap, var_DiffuseTex);\n"
"\n"
"#if defined(USE_ALPHA_TEST)\n"
"	if (u_AlphaTestType == ALPHA_TEST_GT0)\n"
"	{\n"
"		if (color.a == 0.0)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTestType == ALPHA_TEST_LT128)\n"
"	{\n"
"		if (color.a >= 0.5)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTestType == ALPHA_TEST_GE128)\n"
"	{\n"
"		if (color.a < 0.5)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTestType == ALPHA_TEST_GE192)\n"
"	{\n"
"		if (color.a < 0.75)\n"
"			discard;\n"
"	}\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"	float fog = CalcFog(u_ViewOrigin, var_WSPosition, u_FogPlane, u_FogDepthToOpaque, u_FogHasPlane);\n"
"	color *= vec4(1.0) - u_FogColorMask * fog;\n"
"#endif\n"
"\n"
"	out_Color = color * var_Color;\n"
"\n"
"#if defined(USE_GLOW_BUFFER)\n"
"	out_Glow = out_Color;\n"
"#else\n"
"	out_Glow = vec4(0.0);\n"
"#endif\n"
"}\n"
"";
GPUShaderDesc fallback_genericShaders[] = {
  { GPUSHADER_VERTEX, fallback_generic_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_generic_fp, 359 },
};
extern const GPUProgramDesc fallback_genericProgram = { 2, fallback_genericShaders };

const char *fallback_lightall_vp = "#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#define PER_PIXEL_LIGHTING\n"
"#endif\n"
"in vec2 attr_TexCoord0;\n"
"#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)\n"
"in vec2 attr_TexCoord1;\n"
"in vec2 attr_TexCoord2;\n"
"in vec2 attr_TexCoord3;\n"
"in vec2 attr_TexCoord4;\n"
"#endif\n"
"in vec4 attr_Color;\n"
"\n"
"in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"in vec4 attr_Tangent;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"in vec3 attr_Position2;\n"
"in vec3 attr_Normal2;\n"
"in vec4 attr_Tangent2;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"in uvec4 attr_BoneIndexes;\n"
"in vec4 attr_BoneWeights;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_LIGHT_VECTOR)\n"
"in vec3 attr_LightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform vec4   u_EnableTextures; // x = normal, y = deluxe, z = specular, w = cube\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"uniform vec3 u_ViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_LIGHTMAP)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_LocalViewOrigin;\n"
"uniform int u_TCGen1;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float u_VertexLerp;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"uniform mat4x3 u_BoneMatrices[20];\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"uniform vec4 u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"  #if defined(USE_FAST_LIGHT)\n"
"uniform vec3 u_DirectedLight;\n"
"uniform vec3 u_AmbientLight;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec4 u_PrimaryLightOrigin;\n"
"uniform float u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"uniform vec3 u_ViewForward;\n"
"uniform float u_FXVolumetricBase;\n"
"\n"
"out vec4 var_TexCoords;\n"
"out vec4 var_Color;\n"
"out vec3 var_N;\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"out vec4 var_Normal;\n"
"out vec4 var_Tangent;\n"
"out vec4 var_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"out vec4 var_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"out vec4 var_PrimaryLightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_LIGHTMAP)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"	vec2 tex = attr_TexCoord0;\n"
"\n"
"	switch (TCGen)\n"
"	{\n"
"		case TCGEN_LIGHTMAP:\n"
"			tex = attr_TexCoord1;\n"
"		break;\n"
"\n"
"		case TCGEN_LIGHTMAP1:\n"
"			tex = attr_TexCoord2;\n"
"		break;\n"
"\n"
"		case TCGEN_LIGHTMAP2:\n"
"			tex = attr_TexCoord3;\n"
"		break;\n"
"\n"
"		case TCGEN_LIGHTMAP3:\n"
"			tex = attr_TexCoord4;\n"
"		break;\n"
"\n"
"		case TCGEN_ENVIRONMENT_MAPPED:\n"
"		{\n"
"			vec3 viewer = normalize(u_LocalViewOrigin - position);\n"
"			vec2 ref = reflect(viewer, normal).yz;\n"
"			tex.s = ref.x * -0.5 + 0.5;\n"
"			tex.t = ref.y *  0.5 + 0.5;\n"
"		}\n"
"		break;\n"
"\n"
"		case TCGEN_VECTOR:\n"
"		{\n"
"			tex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"		}\n"
"		break;\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"	st2.x = st.x * texMatrix.x + (st.y * texMatrix.z + offTurb.x);\n"
"	st2.y = st.x * texMatrix.y + (st.y * texMatrix.w + offTurb.y);\n"
"\n"
"	vec2 offsetPos = vec2(position.x + position.z, position.y);\n"
"\n"
"	vec2 texOffset = sin(offsetPos * (2.0 * M_PI / 1024.0) + vec2(phase));\n"
"\n"
"	return st2 + texOffset * amplitude;	\n"
"}\n"
"#endif\n"
"\n"
"\n"
"float CalcLightAttenuation(in bool isPoint, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = 1.0 + mix(0.0, 0.5 * normDist - 1.5, isPoint);\n"
"	return clamp(attenuation, 0.0, 1.0);\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"	vec3 position  = mix(attr_Position,    attr_Position2,    u_VertexLerp);\n"
"	vec3 normal    = mix(attr_Normal,      attr_Normal2,      u_VertexLerp);\n"
"	vec3 tangent   = mix(attr_Tangent.xyz, attr_Tangent2.xyz, u_VertexLerp);\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"	vec4 position4 = vec4(0.0);\n"
"	vec4 normal4 = vec4(0.0);\n"
"	vec4 originalPosition = vec4(attr_Position, 1.0);\n"
"	vec4 originalNormal = vec4(attr_Normal - vec3 (0.5), 0.0);\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	vec4 tangent4 = vec4(0.0);\n"
"	vec4 originalTangent = vec4(attr_Tangent.xyz - vec3(0.5), 0.0);\n"
"#endif\n"
"\n"
"	for (int i = 0; i < 4; i++)\n"
"	{\n"
"		uint boneIndex = attr_BoneIndexes[i];\n"
"\n"
"		mat4 boneMatrix = mat4(\n"
"			vec4(u_BoneMatrices[boneIndex][0], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][1], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][2], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][3], 1.0)\n"
"		);\n"
"\n"
"		position4 += (boneMatrix * originalPosition) * attr_BoneWeights[i];\n"
"		normal4 += (boneMatrix * originalNormal) * attr_BoneWeights[i];\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"		tangent4 += (boneMatrix * originalTangent) * attr_BoneWeights[i];\n"
"#endif\n"
"	}\n"
"\n"
"	vec3 position = position4.xyz;\n"
"	vec3 normal = normalize (normal4.xyz);\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	vec3 tangent = normalize (tangent4.xyz);\n"
"#endif\n"
"#else\n"
"	vec3 position  = attr_Position;\n"
"	vec3 normal    = attr_Normal;\n"
"  #if defined(PER_PIXEL_LIGHTING)\n"
"	vec3 tangent   = attr_Tangent.xyz;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if !defined(USE_SKELETAL_ANIMATION)\n"
"	normal  = normal  * 2.0 - vec3(1.0);\n"
"  #if defined(PER_PIXEL_LIGHTING)\n"
"	tangent = tangent * 2.0 - vec3(1.0);\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords(u_TCGen0, position, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"	vec2 texCoords = attr_TexCoord0.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	var_TexCoords.xy = ModTexCoords(texCoords, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"	var_TexCoords.xy = texCoords;\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"	position  = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"	normal    = (u_ModelMatrix * vec4(normal,   0.0)).xyz;\n"
"  #if defined(PER_PIXEL_LIGHTING)\n"
"	tangent   = (u_ModelMatrix * vec4(tangent,  0.0)).xyz;\n"
"  #endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	vec3 bitangent = cross(normal, tangent) * (attr_Tangent.w * 2.0 - 1.0);\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"	vec3 L = u_LightOrigin.xyz - (position * u_LightOrigin.w);\n"
"#elif defined(PER_PIXEL_LIGHTING)\n"
"	vec3 L = attr_LightDirection * 2.0 - vec3(1.0);\n"
"	L = (u_ModelMatrix * vec4(L, 0.0)).xyz;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"	var_TexCoords.zw = GenTexCoords(u_TCGen1, vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n"
"#endif\n"
"\n"
"	if ( u_FXVolumetricBase > 0.0 )\n"
"	{\n"
"		vec3 viewForward = u_ViewForward;\n"
"\n"
"		float d = clamp(dot(normalize(viewForward), normalize(normal)), 0.0, 1.0);\n"
"		d = d * d;\n"
"		d = d * d;\n"
"\n"
"		var_Color = vec4(u_FXVolumetricBase * (1.0 - d));\n"
"	}\n"
"	else\n"
"	{\n"
"		var_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"\n"
"#if defined(USE_LIGHT_VECTOR) && defined(USE_FAST_LIGHT)\n"
"		float sqrLightDist = dot(L, L);\n"
"		float attenuation = CalcLightAttenuation(u_LightOrigin.w, u_LightRadius * u_LightRadius / sqrLightDist);\n"
"		float NL = clamp(dot(normalize(normal), L) / sqrt(sqrLightDist), 0.0, 1.0);\n"
"\n"
"		var_Color.rgb *= u_DirectedLight * (attenuation * NL) + u_AmbientLight;\n"
"#endif\n"
"	}\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"	var_PrimaryLightDir.xyz = u_PrimaryLightOrigin.xyz - (position * u_PrimaryLightOrigin.w);\n"
"	var_PrimaryLightDir.w = u_PrimaryLightRadius * u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"	var_LightDir = vec4(L, u_LightRadius * u_LightRadius);\n"
"  #else\n"
"	var_LightDir = vec4(L, 0.0);\n"
"  #endif\n"
"  #if defined(USE_DELUXEMAP)\n"
"	var_LightDir -= u_EnableTextures.y * var_LightDir;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	vec3 viewDir = u_ViewOrigin - position;\n"
"\n"
"	// store view direction in tangent space to save on outs\n"
"	var_Normal    = vec4(normal,    viewDir.x);\n"
"	var_Tangent   = vec4(tangent,   viewDir.y);\n"
"	var_Bitangent = vec4(bitangent, viewDir.z);\n"
"#endif\n"
"}\n"
"\n"
"";
const char *fallback_lightall_fp = "#if defined(USE_LIGHT) && !defined(USE_VERTEX_LIGHTING)\n"
"#define PER_PIXEL_LIGHTING\n"
"#endif\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform sampler2D u_DeluxeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"#if defined(USE_CUBEMAP)\n"
"uniform samplerCube u_CubeMap;\n"
"uniform sampler2D u_EnvBrdfMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP) || defined(USE_DELUXEMAP) || defined(USE_SPECULARMAP) || defined(USE_CUBEMAP)\n"
"// y = deluxe, w = cube\n"
"uniform vec4 u_EnableTextures;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR) && !defined(USE_VERTEX_LIGHTING)\n"
"uniform vec3 u_DirectedLight;\n"
"uniform vec3 u_AmbientLight;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec3 u_PrimaryLightColor;\n"
"uniform vec3 u_PrimaryLightAmbient;\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"uniform vec4 u_NormalScale;\n"
"uniform vec4 u_SpecularScale;\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING) && defined(USE_CUBEMAP)\n"
"uniform vec4 u_CubeMapInfo;\n"
"#endif\n"
"\n"
"#if defined(USE_ALPHA_TEST)\n"
"uniform int u_AlphaTestType;\n"
"#endif\n"
"\n"
"\n"
"in vec4 var_TexCoords;\n"
"in vec4 var_Color;\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"in vec4 var_Normal;\n"
"in vec4 var_Tangent;\n"
"in vec4 var_Bitangent;\n"
"in vec4 var_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"in vec4 var_PrimaryLightDir;\n"
"#endif\n"
"\n"
"out vec4 out_Color;\n"
"out vec4 out_Glow;\n"
"\n"
"#define EPSILON 0.00000001\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"float SampleDepth(sampler2D normalMap, vec2 t)\n"
"{\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"	return 1.0 - texture(normalMap, t).r;\n"
"  #else\n"
"	return 1.0 - texture(normalMap, t).a;\n"
"  #endif\n"
"}\n"
"\n"
"float RayIntersectDisplaceMap(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"	const int linearSearchSteps = 16;\n"
"	const int binarySearchSteps = 6;\n"
"\n"
"	// current size of search window\n"
"	float size = 1.0 / float(linearSearchSteps);\n"
"\n"
"	// current depth position\n"
"	float depth = 0.0;\n"
"\n"
"	// best match found (starts with last position 1.0)\n"
"	float bestDepth = 1.0;\n"
"\n"
"	// search front to back for first point inside object\n"
"	for(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"	{\n"
"		depth += size;\n"
"		\n"
"		float t = SampleDepth(normalMap, dp + ds * depth);\n"
"		\n"
"		if(bestDepth > 0.996)		// if no depth found yet\n"
"			if(depth >= t)\n"
"				bestDepth = depth;	// store best depth\n"
"	}\n"
"\n"
"	depth = bestDepth;\n"
"	\n"
"	// recurse around first point (depth) for closest match\n"
"	for(int i = 0; i < binarySearchSteps; ++i)\n"
"	{\n"
"		size *= 0.5;\n"
"\n"
"		float t = SampleDepth(normalMap, dp + ds * depth);\n"
"		\n"
"		if(depth >= t)\n"
"		{\n"
"			bestDepth = depth;\n"
"			depth -= 2.0 * size;\n"
"		}\n"
"\n"
"		depth += size;\n"
"	}\n"
"\n"
"	return bestDepth;\n"
"}\n"
"#endif\n"
"\n"
"vec3 CalcFresnel( in vec3 f0, in vec3 f90, in float LH )\n"
"{\n"
"	return f0 + (f90 - f0) * pow(1.0 - LH, 5.0);\n"
"}\n"
"\n"
"float CalcGGX( in float NH, in float roughness )\n"
"{\n"
"	float alphaSq = roughness*roughness;\n"
"	float f = (NH * alphaSq - NH) * NH + 1.0;\n"
"	return alphaSq / (f * f);\n"
"}\n"
"\n"
"float CalcVisibility( in float NL, in float NE, in float roughness )\n"
"{\n"
"	float alphaSq = roughness*roughness;\n"
"\n"
"	float lambdaE = NL * sqrt((-NE * alphaSq + NE) * NE + alphaSq);\n"
"	float lambdaL = NE * sqrt((-NL * alphaSq + NL) * NL + alphaSq);\n"
"\n"
"	return 0.5 / (lambdaE + lambdaL);\n"
"}\n"
"\n"
"// http://www.frostbite.com/2014/11/moving-frostbite-to-pbr/\n"
"vec3 CalcSpecular(\n"
"	in vec3 specular,\n"
"	in float NH,\n"
"	in float NL,\n"
"	in float NE,\n"
"	in float LH,\n"
"	in float roughness\n"
")\n"
"{\n"
"	vec3  F = CalcFresnel(specular, vec3(1.0), LH);\n"
"	float D = CalcGGX(NH, roughness);\n"
"	float V = CalcVisibility(NL, NE, roughness);\n"
"\n"
"	return D * F * V;\n"
"}\n"
"\n"
"vec3 CalcDiffuse(\n"
"	in vec3 diffuse,\n"
"	in float NE,\n"
"	in float NL,\n"
"	in float LH,\n"
"	in float roughness\n"
")\n"
"{\n"
"	return diffuse;\n"
"}\n"
"\n"
"float CalcLightAttenuation(float point, float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) * point + 1.0;\n"
"	return clamp(attenuation, 0.0, 1.0);\n"
"}\n"
"\n"
"vec2 GetParallaxOffset(in vec2 texCoords, in vec3 E, in mat3 tangentToWorld )\n"
"{\n"
"#if defined(USE_PARALLAXMAP)\n"
"	vec3 offsetDir = normalize(E * tangentToWorld);\n"
"	offsetDir.xy *= -u_NormalScale.a / offsetDir.z;\n"
"\n"
"	return offsetDir.xy * RayIntersectDisplaceMap(texCoords, offsetDir.xy, u_NormalMap);\n"
"#else\n"
"	return vec2(0.0);\n"
"#endif\n"
"}\n"
"\n"
"vec3 CalcIBLContribution(\n"
"	in float roughness,\n"
"	in vec3 N,\n"
"	in vec3 E,\n"
"	in vec3 viewDir,\n"
"	in float NE,\n"
"	in vec3 specular\n"
")\n"
"{\n"
"#if defined(USE_CUBEMAP)\n"
"	vec3 EnvBRDF = texture(u_EnvBrdfMap, vec2(roughness, NE)).rgb;\n"
"\n"
"	vec3 R = reflect(E, N);\n"
"\n"
"	// parallax corrected cubemap (cheaper trick)\n"
"	// from http://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/\n"
"	vec3 parallax = u_CubeMapInfo.xyz + u_CubeMapInfo.w * viewDir;\n"
"\n"
"	vec3 cubeLightColor = textureLod(u_CubeMap, R + parallax, roughness * ROUGHNESS_MIPS).rgb * u_EnableTextures.w;\n"
"\n"
"	return cubeLightColor * (specular.rgb * EnvBRDF.x + EnvBRDF.y);\n"
"#else\n"
"	return vec3(0.0);\n"
"#endif\n"
"}\n"
"\n"
"vec3 CalcNormal( in vec3 vertexNormal, in vec2 texCoords, in mat3 tangentToWorld )\n"
"{\n"
"	vec3 N = vertexNormal;\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"	N.xy = texture(u_NormalMap, texCoords).ag - vec2(0.5);\n"
"  #else\n"
"	N.xy = texture(u_NormalMap, texCoords).rg - vec2(0.5);\n"
"  #endif\n"
"\n"
"	N.xy *= u_NormalScale.xy;\n"
"	N.z = sqrt(clamp((0.25 - N.x * N.x) - N.y * N.y, 0.0, 1.0));\n"
"	N = tangentToWorld * N;\n"
"#endif\n"
"\n"
"	return normalize(N);\n"
"}\n"
"\n"
"vec3 sRGBToLinear( in vec3 srgb )\n"
"{\n"
"	vec3 lo = srgb / 12.92;\n"
"	vec3 hi = pow(((srgb + vec3(0.055)) / 1.055), vec3(2.4));\n"
"	return mix(lo, hi, greaterThan(srgb, vec3(0.04045)));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 viewDir, lightColor, ambientColor;\n"
"	vec3 L, N, E;\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	mat3 tangentToWorld = mat3(var_Tangent.xyz, var_Bitangent.xyz, var_Normal.xyz);\n"
"	viewDir = vec3(var_Normal.w, var_Tangent.w, var_Bitangent.w);\n"
"	E = normalize(viewDir);\n"
"	L = var_LightDir.xyz;\n"
"  #if defined(USE_DELUXEMAP)\n"
"	L += (texture(u_DeluxeMap, var_TexCoords.zw).xyz - vec3(0.5)) * u_EnableTextures.y;\n"
"  #endif\n"
"	float sqrLightDist = dot(L, L);\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"	vec4 lightmapColor = texture(u_LightMap, var_TexCoords.zw);\n"
"  #if defined(RGBM_LIGHTMAP)\n"
"	lightmapColor.rgb *= lightmapColor.a;\n"
"  #endif\n"
"	//lightmapColor.rgb = sRGBToLinear(lightmapColor.rgb);\n"
"#endif\n"
"\n"
"	vec2 texCoords = var_TexCoords.xy;\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	texCoords += GetParallaxOffset(texCoords, E, tangentToWorld);\n"
"#endif\n"
"\n"
"	vec4 diffuse = texture(u_DiffuseMap, texCoords);\n"
"#if defined(USE_ALPHA_TEST)\n"
"	if (u_AlphaTestType == ALPHA_TEST_GT0)\n"
"	{\n"
"		if (diffuse.a == 0.0)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTestType == ALPHA_TEST_LT128)\n"
"	{\n"
"		if (diffuse.a >= 0.5)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTestType == ALPHA_TEST_GE128)\n"
"	{\n"
"		if (diffuse.a < 0.5)\n"
"			discard;\n"
"	}\n"
"	else if (u_AlphaTestType == ALPHA_TEST_GE192)\n"
"	{\n"
"		if (diffuse.a < 0.75)\n"
"			discard;\n"
"	}\n"
"#endif\n"
"\n"
"	//diffuse.rgb = sRGBToLinear(diffuse.rgb);\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	float attenuation;\n"
"\n"
"  #if defined(USE_LIGHTMAP)\n"
"	lightColor	= lightmapColor.rgb * var_Color.rgb;\n"
"	ambientColor = vec3 (0.0);\n"
"	attenuation = 1.0;\n"
"  #elif defined(USE_LIGHT_VECTOR)\n"
"	lightColor	= u_DirectedLight * var_Color.rgb;\n"
"	ambientColor = u_AmbientLight * var_Color.rgb;\n"
"	attenuation = CalcLightAttenuation(float(var_LightDir.w > 0.0), var_LightDir.w / sqrLightDist);\n"
"  #elif defined(USE_LIGHT_VERTEX)\n"
"	lightColor	= var_Color.rgb;\n"
"	ambientColor = vec3 (0.0);\n"
"	attenuation = 1.0;\n"
"  #endif\n"
"\n"
"	N = CalcNormal(var_Normal.xyz, texCoords, tangentToWorld);\n"
"	L /= sqrt(sqrLightDist);\n"
"\n"
"  #if defined(USE_SHADOWMAP)\n"
"	vec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\n"
"	float shadowValue = texture(u_ShadowMap, shadowTex).r;\n"
"\n"
"	// surfaces not facing the light are always shadowed\n"
"	vec3 primaryLightDir = normalize(var_PrimaryLightDir.xyz);\n"
"	shadowValue = mix(0.0, shadowValue, dot(N, primaryLightDir) > 0.0);\n"
"\n"
"    #if defined(SHADOWMAP_MODULATE)\n"
"	lightColor = mix(u_PrimaryLightAmbient * lightColor, lightColor, shadowValue);\n"
"    #endif\n"
"  #endif\n"
"\n"
"  #if defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)\n"
"	ambientColor = lightColor;\n"
"	float surfNL = clamp(dot(N, L), 0.0, 1.0);\n"
"\n"
"	// Scale the incoming light to compensate for the baked-in light angle\n"
"	// attenuation.\n"
"	lightColor /= max(surfNL, 0.25);\n"
"\n"
"	// Recover any unused light as ambient, in case attenuation is over 4x or\n"
"	// light is below the surface\n"
"	ambientColor = clamp(ambientColor - lightColor * surfNL, 0.0, 1.0);\n"
"  #endif\n"
"\n"
"	vec4 specular = vec4(1.0);\n"
"  #if defined(USE_SPECULARMAP)\n"
"	specular = texture(u_SpecularMap, texCoords);\n"
"	//specular.rgb = sRGBToLinear(specular.rgb);\n"
"  #endif\n"
"	specular *= u_SpecularScale;\n"
"\n"
"	// diffuse is actually base color, and red of specular is metalness\n"
"	const vec3 DIELECTRIC_SPECULAR = vec3(0.04);\n"
"	const vec3 METAL_DIFFUSE       = vec3(0.0);\n"
"\n"
"	float metalness = specular.r;\n"
"	float roughness = max(specular.a, 0.02);\n"
"	specular.rgb = mix(DIELECTRIC_SPECULAR, diffuse.rgb,   metalness);\n"
"	diffuse.rgb  = mix(diffuse.rgb,         METAL_DIFFUSE, metalness);\n"
"\n"
"	vec3  H  = normalize(L + E);\n"
"	float NE = abs(dot(N, E)) + 1e-5;\n"
"	float NL = clamp(dot(N, L), 0.0, 1.0);\n"
"	float LH = clamp(dot(L, H), 0.0, 1.0);\n"
"\n"
"	vec3  Fd = CalcDiffuse(diffuse.rgb, NE, NL, LH, roughness);\n"
"	vec3  Fs = vec3(0.0);\n"
"\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"	float NH = clamp(dot(N, H), 0.0, 1.0);\n"
"\n"
"	Fs = CalcSpecular(specular.rgb, NH, NL, NE, LH, roughness);\n"
"  #endif\n"
"\n"
"	vec3 reflectance = Fd + Fs;\n"
"\n"
"	out_Color.rgb  = lightColor * reflectance * (attenuation * NL);\n"
"	out_Color.rgb += ambientColor * diffuse.rgb;\n"
"	\n"
"  #if defined(USE_PRIMARY_LIGHT)\n"
"	vec3  L2   = normalize(var_PrimaryLightDir.xyz);\n"
"	vec3  H2   = normalize(L2 + E);\n"
"	float NL2  = clamp(dot(N,  L2), 0.0, 1.0);\n"
"	float L2H2 = clamp(dot(L2, H2), 0.0, 1.0);\n"
"	float NH2  = clamp(dot(N,  H2), 0.0, 1.0);\n"
"\n"
"	reflectance  = CalcDiffuse(diffuse.rgb, NE, NL2, L2H2, roughness);\n"
"	reflectance += CalcSpecular(specular.rgb, NH2, NL2, NE, L2H2, roughness);\n"
"\n"
"	lightColor = u_PrimaryLightColor * var_Color.rgb;\n"
"    #if defined(USE_SHADOWMAP)\n"
"	lightColor *= shadowValue;\n"
"    #endif\n"
"\n"
"	out_Color.rgb += lightColor * reflectance * NL2;\n"
"  #endif\n"
"	\n"
"	out_Color.rgb += CalcIBLContribution(roughness, N, E, viewDir, NE, specular.rgb);\n"
"\n"
"#else\n"
"	lightColor = var_Color.rgb;\n"
"  #if defined(USE_LIGHTMAP) \n"
"	lightColor *= lightmapColor.rgb;\n"
"  #endif\n"
"\n"
"    out_Color.rgb = diffuse.rgb * lightColor;\n"
"#endif\n"
"	\n"
"	out_Color.a = diffuse.a * var_Color.a;\n"
"\n"
"#if defined(USE_GLOW_BUFFER)\n"
"	out_Glow = out_Color;\n"
"#else\n"
"	out_Glow = vec4(0.0);\n"
"#endif\n"
"}\n"
"";
GPUShaderDesc fallback_lightallShaders[] = {
  { GPUSHADER_VERTEX, fallback_lightall_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_lightall_fp, 307 },
};
extern const GPUProgramDesc fallback_lightallProgram = { 2, fallback_lightallShaders };

const char *fallback_prefilterEnvMap_vp = "in vec4 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"out vec2 var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = attr_Position;\n"
"	var_ScreenTex = attr_TexCoord0.xy;\n"
"}\n"
"\n"
"";
const char *fallback_prefilterEnvMap_fp = "uniform vec4 u_ViewInfo; // cubeface, mip_level, max_mip_level, roughness\n"
"uniform samplerCube u_CubeMap;\n"
"in vec2 var_ScreenTex;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"// from http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n"
"float radicalInverse_VdC(uint bits) {\n"
"     bits = (bits << 16u) | (bits >> 16u);\n"
"     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n"
"     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n"
"     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n"
"     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n"
"     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n"
"}\n"
"\n"
"vec2 hammersley2D(uint i, uint N) {\n"
"     return vec2(float(i)/float(N), radicalInverse_VdC(i));\n"
"}\n"
"\n"
"vec3 ImportanceSampleGGX(vec2 Xi, float Roughness, vec3 N)\n"
"{\n"
"	float a = Roughness * Roughness;\n"
"	float Phi = 2 * M_PI * Xi.x;\n"
"	float CosTheta = sqrt((1-Xi.y) / (1+(a*a -1) * Xi.y));\n"
"	float SinTheta = sqrt( 1 - CosTheta * CosTheta);\n"
"\n"
"	vec3 H;\n"
"	H.x = SinTheta * cos( Phi );\n"
"	H.y = SinTheta * sin( Phi );\n"
"	H.z = CosTheta;\n"
"\n"
"	vec3 UpVector = abs(N.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);\n"
"	vec3 TangentX = normalize(cross(UpVector , N));\n"
"	vec3 TangentY = cross(N , TangentX);\n"
"\n"
"	return TangentX * H.x + TangentY * H.y + N * H.z;\n"
"}\n"
"\n"
"vec3 PrefilterEnvMap( float Roughness, vec3 R )\n"
"{\n"
"	vec3 N = R;\n"
"	vec3 V = R;\n"
"	vec3 PrefilteredColor = vec3(0.0);\n"
"	float TotalWeight = 0.0;\n"
"	uint NumSamples = 1024u;\n"
"	for ( uint i = 0u; i < NumSamples; i++ )\n"
"	{\n"
"		vec2 Xi = hammersley2D( i, NumSamples );\n"
"		vec3 H = ImportanceSampleGGX( Xi, Roughness, N );\n"
"		vec3 L = 2 * dot( V, H ) * H - V;\n"
"		float NoL = clamp((dot( N, L )),0.0,1.0);\n"
"		if ( NoL > 0 )\n"
"		{\n"
"			PrefilteredColor += textureLod(u_CubeMap, L, 0.0).rgb * NoL;\n"
"			TotalWeight += NoL;\n"
"		}\n"
"	}\n"
"	return PrefilteredColor / TotalWeight;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float cubeFace = u_ViewInfo.x;\n"
"	vec2 vector = (var_ScreenTex - vec2(0.5)) * 2.0;\n"
"	// from http://www.codinglabs.net/article_physically_based_rendering.aspx\n"
"\n"
"    vec3 normal = normalize( vec3(vector.xy, 1) );\n"
"    if(cubeFace==2)\n"
"        normal = normalize( vec3(vector.x,  1, -vector.y) );\n"
"    else if(cubeFace==3)\n"
"        normal = normalize( vec3(vector.x, -1,  vector.y) );\n"
"    else if(cubeFace==0)\n"
"        normal = normalize( vec3(  1, vector.y,-vector.x) );\n"
"    else if(cubeFace==1)\n"
"        normal = normalize( vec3( -1, vector.y, vector.x) );\n"
"    else if(cubeFace==5)\n"
"        normal = normalize( vec3(-vector.x, vector.y, -1) );\n"
"\n"
"	float roughness = u_ViewInfo.w;\n"
"\n"
"	vec3 result = PrefilterEnvMap(roughness, normal);\n"
"			\n"
"	out_Color = vec4(result, 1.0);\n"
"}";
GPUShaderDesc fallback_prefilterEnvMapShaders[] = {
  { GPUSHADER_VERTEX, fallback_prefilterEnvMap_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_prefilterEnvMap_fp, 14 },
};
extern const GPUProgramDesc fallback_prefilterEnvMapProgram = { 2, fallback_prefilterEnvMapShaders };

const char *fallback_pshadow_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec3 var_Position;\n"
"out vec3 var_Normal;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"\n"
"	var_Position  = attr_Position;\n"
"	var_Normal    = attr_Normal * 2.0 - vec3(1.0);\n"
"}\n"
"\n"
"";
const char *fallback_pshadow_fp = "uniform sampler2D u_ShadowMap;\n"
"uniform vec3 u_LightForward;\n"
"uniform vec3 u_LightUp;\n"
"uniform vec3 u_LightRight;\n"
"uniform vec4 u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"\n"
"in vec3 var_Position;\n"
"in vec3 var_Normal;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"float sampleDistMap(sampler2D texMap, vec2 uv, float scale)\n"
"{\n"
"	vec3 distv = texture(texMap, uv).xyz;\n"
"	return dot(distv, vec3(1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0)) * scale;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 lightToPos = var_Position - u_LightOrigin.xyz;\n"
"	vec2 st = vec2(-dot(u_LightRight, lightToPos), dot(u_LightUp, lightToPos));\n"
"	\n"
"	float fade = length(st);\n"
"	\n"
"#if defined(USE_DISCARD)\n"
"	if (fade >= 1.0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"#endif\n"
"\n"
"	fade = clamp(8.0 - fade * 8.0, 0.0, 1.0);\n"
"	\n"
"	st = st * 0.5 + vec2(0.5);\n"
"\n"
"#if defined(USE_SOLID_PSHADOWS)\n"
"	float intensity = max(sign(u_LightRadius - length(lightToPos)), 0.0);\n"
"#else\n"
"	float intensity = clamp((1.0 - dot(lightToPos, lightToPos) / (u_LightRadius * u_LightRadius)) * 2.0, 0.0, 1.0);\n"
"#endif\n"
"	\n"
"	float lightDist = length(lightToPos);\n"
"	float dist;\n"
"\n"
"#if defined(USE_DISCARD)\n"
"	if (dot(u_LightForward, lightToPos) <= 0.0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"\n"
"	if (dot(var_Normal, lightToPos) > 0.0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"#else\n"
"	intensity *= max(sign(dot(u_LightForward, lightToPos)), 0.0);\n"
"	intensity *= max(sign(-dot(var_Normal, lightToPos)), 0.0);\n"
"#endif\n"
"\n"
"	intensity *= fade;\n"
"#if defined(USE_PCF)\n"
"	float part;\n"
"	\n"
"	dist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/512.0, -1.0/512.0), u_LightRadius);\n"
"	part =  max(sign(lightDist - dist), 0.0);\n"
"\n"
"	dist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0, -1.0/512.0), u_LightRadius);\n"
"	part += max(sign(lightDist - dist), 0.0);\n"
"\n"
"	dist = sampleDistMap(u_ShadowMap, st + vec2(-1.0/512.0,  1.0/512.0), u_LightRadius);\n"
"	part += max(sign(lightDist - dist), 0.0);\n"
"\n"
"	dist = sampleDistMap(u_ShadowMap, st + vec2( 1.0/512.0,  1.0/512.0), u_LightRadius);\n"
"	part += max(sign(lightDist - dist), 0.0);\n"
"\n"
"  #if defined(USE_DISCARD)\n"
"	if (part <= 0.0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"  #endif\n"
"\n"
"	intensity *= part * 0.25;\n"
"#else\n"
"	dist = sampleDistMap(u_ShadowMap, st, u_LightRadius);\n"
"\n"
"  #if defined(USE_DISCARD)\n"
"	if (lightDist - dist <= 0.0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"  #endif\n"
"			\n"
"	intensity *= max(sign(lightDist - dist), 0.0);\n"
"#endif\n"
"		\n"
"	out_Color.rgb = vec3(0.0);\n"
"	out_Color.a = clamp(intensity, 0.0, 0.75);\n"
"}\n"
"";
GPUShaderDesc fallback_pshadowShaders[] = {
  { GPUSHADER_VERTEX, fallback_pshadow_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_pshadow_fp, 20 },
};
extern const GPUProgramDesc fallback_pshadowProgram = { 2, fallback_pshadowShaders };

const char *fallback_shadowfill_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"in vec3 attr_Position2;\n"
"in vec3 attr_Normal2;\n"
"\n"
"uniform int u_DeformType;\n"
"uniform int u_DeformFunc;\n"
"uniform float u_DeformParams[7];\n"
"\n"
"uniform float u_Time;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"uniform float u_VertexLerp;\n"
"\n"
"float GetNoiseValue( float x, float y, float z, float t )\n"
"{\n"
"	// Variation on the 'one-liner random function'.\n"
"	// Not sure if this is still 'correctly' random\n"
"	return fract( sin( dot(\n"
"		vec4( x, y, z, t ),\n"
"		vec4( 12.9898, 78.233, 12.9898, 78.233 )\n"
"	)) * 43758.5453 );\n"
"}\n"
"\n"
"float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )\n"
"{\n"
"	float value = phase + time * frequency;\n"
"\n"
"	switch ( func )\n"
"	{\n"
"		case WF_SIN:\n"
"			return sin(value * 2.0 * M_PI);\n"
"		case WF_SQUARE:\n"
"			return sign(0.5 - fract(value));\n"
"		case WF_TRIANGLE:\n"
"			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"		case WF_SAWTOOTH:\n"
"			return fract(value);\n"
"		case WF_INVERSE_SAWTOOTH:\n"
"			return 1.0 - fract(value);\n"
"		default:\n"
"			return 0.0;\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"	switch ( u_DeformType )\n"
"	{\n"
"		default:\n"
"		{\n"
"			return pos;\n"
"		}\n"
"\n"
"		case DEFORM_BULGE:\n"
"		{\n"
"			float bulgeHeight = u_DeformParams[1]; // amplitude\n"
"			float bulgeWidth = u_DeformParams[2]; // phase\n"
"			float bulgeSpeed = u_DeformParams[3]; // frequency\n"
"\n"
"			float scale = CalculateDeformScale( WF_SIN, u_Time, bulgeWidth * st.x, bulgeSpeed );\n"
"\n"
"			return pos + normal * scale * bulgeHeight;\n"
"		}\n"
"\n"
"		case DEFORM_WAVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			float spread = u_DeformParams[4];\n"
"\n"
"			float offset = dot( pos.xyz, vec3( spread ) );\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase + offset, frequency );\n"
"\n"
"			return pos + normal * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_MOVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			vec3 direction = vec3( u_DeformParams[4], u_DeformParams[5], u_DeformParams[6] );\n"
"\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase, frequency );\n"
"\n"
"			return pos + direction * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_PROJECTION_SHADOW:\n"
"		{\n"
"			vec3 ground = vec3(\n"
"				u_DeformParams[0],\n"
"				u_DeformParams[1],\n"
"				u_DeformParams[2]);\n"
"			float groundDist = u_DeformParams[3];\n"
"			vec3 lightDir = vec3(\n"
"				u_DeformParams[4],\n"
"				u_DeformParams[5],\n"
"				u_DeformParams[6]);\n"
"\n"
"			float d = dot( lightDir, ground );\n"
"\n"
"			lightDir = lightDir * max( 0.5 - d, 0.0 ) + ground;\n"
"			d = 1.0 / dot( lightDir, ground );\n"
"\n"
"			vec3 lightPos = lightDir * d;\n"
"\n"
"			return pos - lightPos * dot( pos, ground ) + groundDist;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformNormal( const in vec3 position, const in vec3 normal )\n"
"{\n"
"	if ( u_DeformType != DEFORM_NORMALS )\n"
"	{\n"
"		return normal;\n"
"	}\n"
"\n"
"	float amplitude = u_DeformParams[1];\n"
"	float frequency = u_DeformParams[3];\n"
"\n"
"	vec3 outNormal = normal;\n"
"	const float scale = 0.98;\n"
"	\n"
"	outNormal.x += amplitude * GetNoiseValue(\n"
"		position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.y += amplitude * GetNoiseValue(\n"
"		100.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.z += amplitude * GetNoiseValue(\n"
"		200.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	return outNormal;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 position  = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"	vec3 normal    = mix(attr_Normal,   attr_Normal2,   u_VertexLerp);\n"
"	normal = normalize(normal - vec3(0.5));\n"
"\n"
"	position = DeformPosition(position, normal, attr_TexCoord0.st);\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"}\n"
"\n"
"";
const char *fallback_shadowfill_fp = "out vec4 out_Color;\n"
"void main()\n"
"{\n"
"	out_Color = vec4(0, 0, 0, 1);\n"
"}\n"
"";
GPUShaderDesc fallback_shadowfillShaders[] = {
  { GPUSHADER_VERTEX, fallback_shadowfill_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_shadowfill_fp, 165 },
};
extern const GPUProgramDesc fallback_shadowfillProgram = { 2, fallback_shadowfillShaders };

const char *fallback_shadowmask_vp = "in vec4 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform vec3 u_ViewForward;\n"
"uniform vec3 u_ViewLeft;\n"
"uniform vec3 u_ViewUp;\n"
"uniform vec4 u_ViewInfo; // zfar / znear\n"
"\n"
"out vec2 var_DepthTex;\n"
"out vec3 var_ViewDir;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = attr_Position;\n"
"	vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	var_DepthTex = attr_TexCoord0.xy;\n"
"	var_ViewDir = u_ViewForward + u_ViewLeft * -screenCoords.x + u_ViewUp * screenCoords.y;\n"
"}\n"
"\n"
"";
const char *fallback_shadowmask_fp = "uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform sampler2D u_ShadowMap;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform sampler2D u_ShadowMap2;\n"
"uniform sampler2D u_ShadowMap3;\n"
"#endif\n"
"\n"
"uniform mat4 u_ShadowMvp;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform mat4 u_ShadowMvp2;\n"
"uniform mat4 u_ShadowMvp3;\n"
"#endif\n"
"\n"
"uniform vec3 u_ViewOrigin;\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"in vec2 var_DepthTex;\n"
"in vec3 var_ViewDir;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"// depth is GL_DEPTH_COMPONENT24\n"
"// so the maximum error is 1.0 / 2^24\n"
"#define DEPTH_MAX_ERROR 0.000000059604644775390625\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  \n"
"}\n"
"\n"
"float PCF(const sampler2D shadowmap, const vec2 st, const float dist)\n"
"{\n"
"	float mult;\n"
"	float scale = 2.0 / r_shadowMapSize;\n"
"\n"
"#if defined(USE_SHADOW_FILTER)\n"
"	float r = random(var_DepthTex.xy);\n"
"	float sinr = sin(r) * scale;\n"
"	float cosr = cos(r) * scale;\n"
"	mat2 rmat = mat2(cosr, sinr, -sinr, cosr);\n"
"\n"
"	mult =  step(dist, texture(shadowmap, st + rmat * vec2(-0.7055767, 0.196515)).r);\n"
"	mult += step(dist, texture(shadowmap, st + rmat * vec2(0.3524343, -0.7791386)).r);\n"
"	mult += step(dist, texture(shadowmap, st + rmat * vec2(0.2391056, 0.9189604)).r);\n"
"  #if defined(USE_SHADOW_FILTER2)\n"
"	mult += step(dist, texture(shadowmap, st + rmat * vec2(-0.07580382, -0.09224417)).r);\n"
"	mult += step(dist, texture(shadowmap, st + rmat * vec2(0.5784913, -0.002528916)).r);\n"
"	mult += step(dist, texture(shadowmap, st + rmat * vec2(0.192888, 0.4064181)).r);\n"
"	mult += step(dist, texture(shadowmap, st + rmat * vec2(-0.6335801, -0.5247476)).r);\n"
"	mult += step(dist, texture(shadowmap, st + rmat * vec2(-0.5579782, 0.7491854)).r);\n"
"	mult += step(dist, texture(shadowmap, st + rmat * vec2(0.7320465, 0.6317794)).r);\n"
"\n"
"	mult *= 0.11111;\n"
"  #else\n"
"    mult *= 0.33333;\n"
"  #endif\n"
"#else\n"
"	mult = step(dist, texture(shadowmap, st).r);\n"
"#endif\n"
"		\n"
"	return mult;\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, vec2 tex, float zFarDivZNear)\n"
"{\n"
"	float sampleZDivW = texture(depthMap, tex).r;\n"
"	sampleZDivW -= DEPTH_MAX_ERROR;\n"
"	return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float result;\n"
"	\n"
"	float depth = getLinearDepth(u_ScreenDepthMap, var_DepthTex, u_ViewInfo.x);\n"
"	float sampleZ = u_ViewInfo.y * depth;\n"
"\n"
"	vec4 biasPos = vec4(u_ViewOrigin + var_ViewDir * (depth - 0.5 / u_ViewInfo.x), 1.0);\n"
"	\n"
"	vec4 shadowpos = u_ShadowMvp * biasPos;\n"
"	\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"	const float fadeTo = 1.0;\n"
"	result = fadeTo;\n"
"#else\n"
"	result = 0.0;\n"
"#endif\n"
"\n"
"	if (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"	{\n"
"		shadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\n"
"		result = PCF(u_ShadowMap, shadowpos.xy, shadowpos.z);\n"
"	}\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"	else\n"
"	{\n"
"		shadowpos = u_ShadowMvp2 * biasPos;\n"
"\n"
"		if (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"		{\n"
"			shadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\n"
"			result = PCF(u_ShadowMap2, shadowpos.xy, shadowpos.z);\n"
"		}\n"
"		else\n"
"		{\n"
"			shadowpos = u_ShadowMvp3 * biasPos;\n"
"\n"
"			if (all(lessThanEqual(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"			{\n"
"				shadowpos.xyz = shadowpos.xyz / shadowpos.w * 0.5 + 0.5;\n"
"				result = PCF(u_ShadowMap3, shadowpos.xy, shadowpos.z);\n"
"\n"
"				float fade = clamp(sampleZ / r_shadowCascadeZFar * 10.0 - 9.0, 0.0, 1.0);\n"
"				result = mix(result, fadeTo, fade);\n"
"			}\n"
"		}\n"
"	}\n"
"#endif\n"
"		\n"
"	out_Color = vec4(vec3(result), 1.0);\n"
"}\n"
"";
GPUShaderDesc fallback_shadowmaskShaders[] = {
  { GPUSHADER_VERTEX, fallback_shadowmask_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_shadowmask_fp, 22 },
};
extern const GPUProgramDesc fallback_shadowmaskProgram = { 2, fallback_shadowmaskShaders };

const char *fallback_ssao_vp = "in vec4 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"out vec2 var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = attr_Position;\n"
"	var_ScreenTex = attr_TexCoord0.xy;\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
"\n"
"";
const char *fallback_ssao_fp = "uniform sampler2D u_ScreenDepthMap;\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"in vec2 var_ScreenTex;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"vec2 poissonDisc[9] = vec2[9](\n"
"vec2(-0.7055767, 0.196515),    vec2(0.3524343, -0.7791386),\n"
"vec2(0.2391056, 0.9189604),    vec2(-0.07580382, -0.09224417),\n"
"vec2(0.5784913, -0.002528916), vec2(0.192888, 0.4064181),\n"
"vec2(-0.6335801, -0.5247476),  vec2(-0.5579782, 0.7491854),\n"
"vec2(0.7320465, 0.6317794)\n"
");\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  \n"
"}\n"
"\n"
"mat2 randomRotation( const vec2 p )\n"
"{\n"
"	float r = random(p);\n"
"	float sinr = sin(r);\n"
"	float cosr = cos(r);\n"
"	return mat2(cosr, sinr, -sinr, cosr);\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"		float sampleZDivW = texture(depthMap, tex).r;\n"
"		return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"float ambientOcclusion(sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const float zFar)\n"
"{\n"
"	float result = 0;\n"
"\n"
"	float sampleZ = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"\n"
"	vec2 expectedSlope = vec2(dFdx(sampleZ), dFdy(sampleZ)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"	\n"
"	if (length(expectedSlope) > 5000.0)\n"
"		return 1.0;\n"
"	\n"
"	vec2 offsetScale = vec2(3.0 / sampleZ);\n"
"	\n"
"	mat2 rmat = randomRotation(tex);\n"
"		\n"
"	int i;\n"
"	for (i = 0; i < 3; i++)\n"
"	{\n"
"		vec2 offset = rmat * poissonDisc[i] * offsetScale;\n"
"		float sampleZ2 = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"\n"
"		if (abs(sampleZ - sampleZ2) > 20.0)\n"
"			result += 1.0;\n"
"		else\n"
"		{\n"
"			float expectedZ = sampleZ + dot(expectedSlope, offset);\n"
"			result += step(expectedZ - 1.0, sampleZ2);\n"
"		}\n"
"	}\n"
"	\n"
"	result *= 0.33333;\n"
"	\n"
"	return result;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float result = ambientOcclusion(u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);\n"
"			\n"
"	out_Color = vec4(vec3(result), 1.0);\n"
"}\n"
"";
GPUShaderDesc fallback_ssaoShaders[] = {
  { GPUSHADER_VERTEX, fallback_ssao_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_ssao_fp, 16 },
};
extern const GPUProgramDesc fallback_ssaoProgram = { 2, fallback_ssaoShaders };

const char *fallback_surface_sprites_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform vec3 u_ViewOrigin;\n"
"\n"
"layout(std140) uniform SurfaceSprite\n"
"{\n"
"	float u_Width;\n"
"	float u_Height;\n"
"	float u_FadeStartDistance;\n"
"	float u_FadeEndDistance;\n"
"	float u_FadeScale;\n"
"	float u_WidthVariance;\n"
"	float u_HeightVariance;\n"
"};\n"
"\n"
"out vec2 var_TexCoords;\n"
"out float var_Alpha;\n"
"\n"
"void main()\n"
"{\n"
"	vec3 V = u_ViewOrigin - attr_Position;\n"
"\n"
"	float width = u_Width * (1.0 + u_WidthVariance*0.5);\n"
"	float height = u_Height * (1.0 + u_HeightVariance*0.5);\n"
"\n"
"	float distanceToCamera = length(V);\n"
"	float fadeScale = smoothstep(u_FadeStartDistance, u_FadeEndDistance,\n"
"						distanceToCamera);\n"
"	width += u_FadeScale * fadeScale * u_Width;\n"
"\n"
"	float halfWidth = width * 0.5;\n"
"	vec3 offsets[] = vec3[](\n"
"#if defined(FACE_UP)\n"
"		vec3( halfWidth, -halfWidth, 0.0),\n"
"		vec3( halfWidth,  halfWidth, 0.0),\n"
"		vec3(-halfWidth,  halfWidth, 0.0),\n"
"		vec3(-halfWidth, -halfWidth, 0.0)\n"
"#else\n"
"		vec3( halfWidth, 0.0, 0.0),\n"
"		vec3( halfWidth, 0.0, height),\n"
"		vec3(-halfWidth, 0.0, height),\n"
"		vec3(-halfWidth, 0.0, 0.0)\n"
"#endif\n"
"	);\n"
"\n"
"	const vec2 texcoords[] = vec2[](\n"
"		vec2(1.0, 1.0),\n"
"		vec2(1.0, 0.0),\n"
"		vec2(0.0, 0.0),\n"
"		vec2(0.0, 1.0)\n"
"	);\n"
"\n"
"	vec3 offset = offsets[gl_VertexID];\n"
"\n"
"#if defined(FACE_CAMERA)\n"
"	vec2 toCamera = normalize(V.xy);\n"
"	offset.xy = offset.x*vec2(toCamera.y, -toCamera.x);\n"
"#elif !defined(FACE_UP)\n"
"	// Make this sprite face in some direction\n"
"	offset.xy = offset.x*attr_Normal.xy;\n"
"#endif\n"
"\n"
"	vec4 worldPos = vec4(attr_Position + offset, 1.0);\n"
"	gl_Position = u_ModelViewProjectionMatrix * worldPos;\n"
"	var_TexCoords = texcoords[gl_VertexID];\n"
"	var_Alpha = 1.0 - fadeScale;\n"
"}\n"
"\n"
"";
const char *fallback_surface_sprites_fp = "uniform sampler2D u_DiffuseMap;\n"
"\n"
"in vec2 var_TexCoords;\n"
"in float var_Alpha;\n"
"\n"
"layout(std140) uniform SurfaceSprite\n"
"{\n"
"	float u_Width;\n"
"	float u_Height;\n"
"	float u_FadeStartDistance;\n"
"	float u_FadeEndDistance;\n"
"	float u_FadeScale;\n"
"	float u_WidthVariance;\n"
"	float u_HeightVariance;\n"
"};\n"
"\n"
"out vec4 out_Color;\n"
"out vec4 out_Glow;\n"
"\n"
"void main()\n"
"{\n"
"	const float alphaTestValue = 0.5;\n"
"	out_Color = texture(u_DiffuseMap, var_TexCoords);\n"
"	out_Color.a *= var_Alpha*(1.0 - alphaTestValue) + alphaTestValue;\n"
"\n"
"#if defined(ALPHA_TEST)\n"
"	if ( out_Color.a < alphaTestValue )\n"
"		discard;\n"
"#endif\n"
"\n"
"	out_Glow = vec4(0.0);\n"
"}\n"
"";
GPUShaderDesc fallback_surface_spritesShaders[] = {
  { GPUSHADER_VERTEX, fallback_surface_sprites_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_surface_sprites_fp, 73 },
};
extern const GPUProgramDesc fallback_surface_spritesProgram = { 2, fallback_surface_spritesShaders };

const char *fallback_texturecolor_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_Tex1;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_Tex1 = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_texturecolor_fp = "uniform sampler2D u_DiffuseMap;\n"
"uniform vec4 u_Color;\n"
"\n"
"in vec2 var_Tex1;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	out_Color = texture(u_DiffuseMap, var_Tex1) * u_Color;\n"
"}\n"
"";
GPUShaderDesc fallback_texturecolorShaders[] = {
  { GPUSHADER_VERTEX, fallback_texturecolor_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_texturecolor_fp, 17 },
};
extern const GPUProgramDesc fallback_texturecolorProgram = { 2, fallback_texturecolorShaders };

const char *fallback_tonemap_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_TexCoords = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_tonemap_fp = "uniform sampler2D u_TextureMap;\n"
"uniform sampler2D u_LevelsMap;\n"
"uniform vec4 u_Color;\n"
"uniform vec2  u_AutoExposureMinMax;\n"
"uniform vec3   u_ToneMinAvgMaxLinear;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 LinearTosRGB( in vec3 color )\n"
"{\n"
"	vec3 clampedColor = clamp(color, 0.0, 1.0);\n"
"\n"
"	vec3 lo = 12.92 * clampedColor;\n"
"	vec3 hi = 1.055 * pow(clampedColor, vec3(0.41666)) - 0.055;\n"
"	return mix(lo, hi, greaterThanEqual(color, vec3(0.0031308)));\n"
"}\n"
"\n"
"vec3 FilmicTonemap(vec3 x)\n"
"{\n"
"	const float SS  = 0.22; // Shoulder Strength\n"
"	const float LS  = 0.30; // Linear Strength\n"
"	const float LA  = 0.10; // Linear Angle\n"
"	const float TS  = 0.20; // Toe Strength\n"
"	const float TAN = 0.01; // Toe Angle Numerator\n"
"	const float TAD = 0.30; // Toe Angle Denominator\n"
"	\n"
"	vec3 SSxx = SS * x * x;\n"
"	vec3 LSx = LS * x;\n"
"	vec3 LALSx = LSx * LA;\n"
"	\n"
"	return ((SSxx + LALSx + TS * TAN) / (SSxx + LSx + TS * TAD)) - TAN / TAD;\n"
"\n"
"	//return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = texture(u_TextureMap, var_TexCoords) * u_Color;\n"
"	vec3 minAvgMax = texture(u_LevelsMap, var_TexCoords).rgb;\n"
"	vec3 logMinAvgMaxLum = clamp(minAvgMax * 20.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x);\n"
"		\n"
"	float avgLum = exp2(logMinAvgMaxLum.y);\n"
"	//float maxLum = exp2(logMinAvgMaxLum.z);\n"
"\n"
"	color.rgb *= u_ToneMinAvgMaxLinear.y / avgLum;\n"
"	color.rgb = max(vec3(0.0), color.rgb - vec3(u_ToneMinAvgMaxLinear.x));\n"
"\n"
"	vec3 fWhite = 1.0 / FilmicTonemap(vec3(u_ToneMinAvgMaxLinear.z - u_ToneMinAvgMaxLinear.x));\n"
"	color.rgb = FilmicTonemap(color.rgb) * fWhite;\n"
"	//color.rgb = LinearTosRGB(color.rgb);\n"
"	\n"
"	out_Color = clamp(color, 0.0, 1.0);\n"
"}\n"
"";
GPUShaderDesc fallback_tonemapShaders[] = {
  { GPUSHADER_VERTEX, fallback_tonemap_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_tonemap_fp, 17 },
};
extern const GPUProgramDesc fallback_tonemapProgram = { 2, fallback_tonemapShaders };

const char *fallback_weather_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Color;\n"
"\n"
"uniform vec2 u_MapZExtents;\n"
"uniform float u_Time;\n"
"uniform vec3 u_ViewOrigin;\n"
"\n"
"void main()\n"
"{\n"
"	int z = gl_InstanceID / 25;\n"
"	int remaining = gl_InstanceID - (z * 25);\n"
"	int y = remaining % 5;\n"
"	int x = remaining / 5;\n"
"\n"
"	float zOffset = mod(\n"
"		1000.0 * float(z) + u_Time * 1000.0,\n"
"		u_MapZExtents.y - u_MapZExtents.x - 2000.0);\n"
"	vec3 offset = vec3(\n"
"		1000.0 * float(x - 2),\n"
"		1000.0 * float(y - 2),\n"
"		u_MapZExtents.y - zOffset);\n"
"	offset.xy += attr_Color.xy * u_Time;\n"
"\n"
"	gl_Position = vec4(attr_Position + offset, 1.0);\n"
"}\n"
"\n"
"";
const char *fallback_weather_fp = "out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	out_Color = vec4(0.7, 0.8, 0.7, 0.4);\n"
"}\n"
"";
const char *fallback_weather_gp = "layout(points) in;\n"
"layout(triangle_strip, max_vertices = 4) out;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform vec3 u_ViewOrigin;\n"
"\n"
"void main()\n"
"{\n"
"	const vec2 offsets[] = vec2[](\n"
"		vec2(-0.5, -7.0),\n"
"		vec2( 0.5, -7.0),\n"
"		vec2(-0.5,  7.0),\n"
"		vec2( 0.5,  7.0)\n"
"	);\n"
"\n"
"	vec3 P = gl_in[0].gl_Position.xyz;\n"
"	vec3 V = u_ViewOrigin - P;\n"
"	vec2 toCamera = normalize(vec2(V.y, -V.x));\n"
"\n"
"	for (int i = 0; i < 4; ++i)\n"
"	{\n"
"		vec3 offset = vec3(offsets[i].x * toCamera.xy, offsets[i].y);\n"
"		vec4 worldPos = vec4(P + offset, 1.0);\n"
"		gl_Position = u_ModelViewProjectionMatrix * worldPos;\n"
"		EmitVertex();\n"
"	}\n"
"\n"
"	EndPrimitive();\n"
"}\n"
"\n"
"";
GPUShaderDesc fallback_weatherShaders[] = {
  { GPUSHADER_VERTEX, fallback_weather_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_weather_fp, 60 },
  { GPUSHADER_GEOMETRY, fallback_weather_gp, 29 },
};
extern const GPUProgramDesc fallback_weatherProgram = { 3, fallback_weatherShaders };

