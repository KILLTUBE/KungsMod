#include "tr_local.h"

const char *fallback_bokeh_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_TexCoords = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_bokeh_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"\n"
"#if 0\n"
"	float c[7] = float[7](1.0, 0.9659258263, 0.8660254038, 0.7071067812, 0.5, 0.2588190451, 0.0);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[6]);  color =  texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[5]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[5],  c[1]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[6],  c[0]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[5]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[5], -c[1]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[6], -c[0]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[6]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[5]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[4],  c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[5],  c[1]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[5]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[4], -c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[5], -c[1]);  color += texture(u_TextureMap, tc);\n"
"	\n"
"	out_Color = color * 0.04166667 * u_Color;\n"
"#endif\n"
"\n"
"	float c[5] = float[5](1.0, 0.9238795325, 0.7071067812, 0.3826834324, 0.0);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[0],  c[4]);  color =  texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[1],  c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[2],  c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[3],  c[1]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[4],  c[0]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[1], -c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[2], -c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[3], -c[1]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(  c[4], -c[0]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[0],  c[4]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[1],  c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[2],  c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[3],  c[1]);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[1], -c[3]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[2], -c[2]);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( -c[3], -c[1]);  color += texture(u_TextureMap, tc);\n"
"	\n"
"	out_Color = color * 0.0625 * u_Color;\n"
"}\n"
"";
GPUShaderDesc fallback_bokehShaders[] = {
  { GPUSHADER_VERTEX, fallback_bokeh_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_bokeh_fp, 16 },
};
extern const GPUProgramDesc fallback_bokehProgram = { 2, fallback_bokehShaders };

const char *fallback_calclevels4x_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_TexCoords = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_calclevels4x_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec4 u_Color;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"const vec3  LUMINANCE_VECTOR = vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 GetValues(vec2 offset, vec3 current)\n"
"{\n"
"	vec2 tc = var_TexCoords + u_InvTexRes * offset;\n"
"	vec3 minAvgMax = texture(u_TextureMap, tc).rgb;\n"
"\n"
"#ifdef FIRST_PASS\n"
"  #if defined(USE_PBR)\n"
"	minAvgMax = pow(minAvgMax, vec3(2.2));\n"
"  #endif\n"
"	float lumi = max(dot(LUMINANCE_VECTOR, minAvgMax), 0.000001);\n"
"	float loglumi = clamp(log2(lumi), -10.0, 10.0);\n"
"	minAvgMax = vec3(loglumi * 0.05 + 0.5);\n"
"#endif\n"
"\n"
"	return vec3(\n"
"		min(current.x, minAvgMax.x),\n"
"		current.y + minAvgMax.y,\n"
"		max(current.z, minAvgMax.z));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 current = vec3(1.0, 0.0, 0.0);\n"
"\n"
"#ifdef FIRST_PASS\n"
"	current = GetValues(vec2( 0.0,  0.0), current);\n"
"#else\n"
"	current = GetValues(vec2(-1.5, -1.5), current);\n"
"	current = GetValues(vec2(-0.5, -1.5), current);\n"
"	current = GetValues(vec2( 0.5, -1.5), current);\n"
"	current = GetValues(vec2( 1.5, -1.5), current);\n"
"	\n"
"	current = GetValues(vec2(-1.5, -0.5), current);\n"
"	current = GetValues(vec2(-0.5, -0.5), current);\n"
"	current = GetValues(vec2( 0.5, -0.5), current);\n"
"	current = GetValues(vec2( 1.5, -0.5), current);\n"
"	\n"
"	current = GetValues(vec2(-1.5,  0.5), current);\n"
"	current = GetValues(vec2(-0.5,  0.5), current);\n"
"	current = GetValues(vec2( 0.5,  0.5), current);\n"
"	current = GetValues(vec2( 1.5,  0.5), current);\n"
"\n"
"	current = GetValues(vec2(-1.5,  1.5), current);\n"
"	current = GetValues(vec2(-0.5,  1.5), current);\n"
"	current = GetValues(vec2( 0.5,  1.5), current);\n"
"	current = GetValues(vec2( 1.5,  1.5), current);\n"
"\n"
"	current.y *= 0.0625;\n"
"#endif\n"
"\n"
"	out_Color = vec4(current, 1.0f);\n"
"}\n"
"";
GPUShaderDesc fallback_calclevels4xShaders[] = {
  { GPUSHADER_VERTEX, fallback_calclevels4x_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_calclevels4x_fp, 16 },
};
extern const GPUProgramDesc fallback_calclevels4xProgram = { 2, fallback_calclevels4xShaders };

const char *fallback_depthblur_vp = "in vec4 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"out vec2 var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = attr_Position;\n"
"	var_ScreenTex = attr_TexCoord0.xy;\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
"\n"
"";
const char *fallback_depthblur_fp = "uniform sampler2D u_ScreenImageMap;\n"
"uniform sampler2D u_ScreenDepthMap;\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"in vec2 var_ScreenTex;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"//float gauss[5] = float[5](0.30, 0.23, 0.097, 0.024, 0.0033);\n"
"float gauss[4] = float[4](0.40, 0.24, 0.054, 0.0044);\n"
"//float gauss[3] = float[3](0.60, 0.19, 0.0066);\n"
"#define GAUSS_SIZE 4\n"
"\n"
"float Offsets[12] = float[](-6.0, -5.0, -4.0, -3.0, -2.0, -1.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0);\n"
"float BlurWeights[12] = float[](1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0);\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"		float sampleZDivW = texture(depthMap, tex).r;\n"
"		return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"vec4 depthGaussian1D(sampler2D imageMap, sampler2D depthMap, vec2 tex, float zFarDivZNear, float zFar)\n"
"{\n"
"	vec2 scale = r_FBufScale * 2.0;\n"
"\n"
"#if defined(USE_HORIZONTAL_BLUR)\n"
"    vec2 direction = vec2(1.0, 0.0) * scale;\n"
"#else // if defined(USE_VERTICAL_BLUR)\n"
"	vec2 direction = vec2(0.0, 1.0) * scale;\n"
"#endif\n"
"\n"
"	float BlurWeightsSum = 10.0;\n"
"	float SSAO = texture(imageMap, tex).r * BlurWeightsSum;\n"
"	float Depth = texture(depthMap, tex).r;\n"
"\n"
"	for (int i = 0; i < 12; i++)\n"
"	{\n"
"		vec2 TexCoord = tex + Offsets[i] * direction;\n"
"		float DepthDifference = abs(Depth - texture(depthMap, TexCoord).r);\n"
"\n"
"		if (DepthDifference < 3.0)\n"
"		{\n"
"			SSAO += texture(imageMap, TexCoord).r * BlurWeights[i];\n"
"			BlurWeightsSum += BlurWeights[i];\n"
"		}\n"
"\n"
"	}\n"
"	return vec4(vec3(SSAO / BlurWeightsSum), 1.0);\n"
"	\n"
"	/*float depthCenter = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"	vec2 centerSlope = vec2(dFdx(depthCenter), dFdy(depthCenter)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"		\n"
"	vec4 result = texture(imageMap, tex) * gauss[0];\n"
"	float total = gauss[0];\n"
"\n"
"	int i, j;\n"
"	for (i = 0; i < 2; i++)\n"
"	{\n"
"		for (j = 1; j < GAUSS_SIZE; j++)\n"
"		{\n"
"			vec2 offset = direction * j;\n"
"			float depthSample = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"			float depthExpected = depthCenter + dot(centerSlope, offset);\n"
"			if(abs(depthSample - depthExpected) < 5.0)\n"
"			{\n"
"				result += texture(imageMap, tex + offset) * gauss[j];\n"
"				total += gauss[j];\n"
"			}\n"
"		}\n"
"		\n"
"		direction = -direction;\n"
"	}	\n"
"		\n"
"	return result / total;*/\n"
"}\n"
"\n"
"void main()\n"
"{		\n"
"	out_Color = depthGaussian1D(u_ScreenImageMap, u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);\n"
"}\n"
"";
GPUShaderDesc fallback_depthblurShaders[] = {
  { GPUSHADER_VERTEX, fallback_depthblur_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_depthblur_fp, 16 },
};
extern const GPUProgramDesc fallback_depthblurProgram = { 2, fallback_depthblurShaders };

const char *fallback_dglow_downsample_vp = "out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	const vec2 positions[] = vec2[3](\n"
"		vec2(-1.0f, -1.0f),\n"
"		vec2(-1.0f,  3.0f),\n"
"		vec2( 3.0f, -1.0f)\n"
"	);\n"
"\n"
"	const vec2 texcoords[] = vec2[3](\n"
"		vec2( 0.0f,  1.0f),\n"
"		vec2( 0.0f, -1.0f),\n"
"		vec2( 2.0f,  1.0f)\n"
"	);\n"
"\n"
"	gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n"
"	var_TexCoords = texcoords[gl_VertexID];\n"
"}\n"
"\n"
"";
const char *fallback_dglow_downsample_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	// Based on \"Next Generation Post Processing in Call of Duty: Advanced Warfare\":\n"
"	// http://advances.realtimerendering.com/s2014/index.html\n"
"	vec4 color = vec4(0.0);\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-2.0, -2.0)));\n"
"	color += 0.5 * 0.25 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 0.0, -2.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 2.0, -2.0)));\n"
"	color += 0.25 * 0.5 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-1.0, -1.0)));\n"
"	color += 0.25 * 0.5 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 1.0, -1.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-2.0,  0.0)));\n"
"	color += 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 0.0,  0.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 2.0, -2.0)));\n"
"	color += 0.25 * 0.5 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-1.0,  1.0)));\n"
"	color += 0.25 * 0.5 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 1.0,  1.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2(-2.0,  2.0)));\n"
"	color += 0.5 * 0.25 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 0.0,  2.0)));\n"
"	color += 0.25 * 0.125 * texture(u_TextureMap, var_TexCoords + (u_InvTexRes * vec2( 2.0,  2.0)));\n"
"\n"
"	out_Color = color;\n"
"}";
GPUShaderDesc fallback_dglow_downsampleShaders[] = {
  { GPUSHADER_VERTEX, fallback_dglow_downsample_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_dglow_downsample_fp, 23 },
};
extern const GPUProgramDesc fallback_dglow_downsampleProgram = { 2, fallback_dglow_downsampleShaders };

const char *fallback_dglow_upsample_vp = "out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	const vec2 positions[] = vec2[3](\n"
"		vec2(-1.0f, -1.0f),\n"
"		vec2(-1.0f,  3.0f),\n"
"		vec2( 3.0f, -1.0f)\n"
"	);\n"
"\n"
"	const vec2 texcoords[] = vec2[3](\n"
"		vec2( 0.0f,  1.0f),\n"
"		vec2( 0.0f, -1.0f),\n"
"		vec2( 2.0f,  1.0f)\n"
"	);\n"
"\n"
"	gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n"
"	var_TexCoords = texcoords[gl_VertexID];\n"
"}\n"
"\n"
"";
const char *fallback_dglow_upsample_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	// Based on \"Next Generation Post Processing in Call of Duty: Advanced Warfare\":\n"
"	// http://advances.realtimerendering.com/s2014/index.html\n"
"	vec4 color = vec4(0.0);\n"
"	color += 0.0625 * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2(-1.0, -1.0));\n"
"	color += 0.125  * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 0.0, -1.0));\n"
"	color += 0.0625 * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 1.0, -1.0));\n"
"	color += 0.125  * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2(-1.0,  0.0));\n"
"	color += 0.25   * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 0.0,  0.0));\n"
"	color += 0.125  * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 1.0,  0.0));\n"
"	color += 0.0625 * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2(-1.0,  1.0));\n"
"	color += 0.125  * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 0.0,  1.0));\n"
"	color += 0.0625 * texture(u_TextureMap, var_TexCoords + u_InvTexRes * vec2( 1.0,  1.0));\n"
"\n"
"	out_Color = color;\n"
"}";
GPUShaderDesc fallback_dglow_upsampleShaders[] = {
  { GPUSHADER_VERTEX, fallback_dglow_upsample_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_dglow_upsample_fp, 23 },
};
extern const GPUProgramDesc fallback_dglow_upsampleProgram = { 2, fallback_dglow_upsampleShaders };

const char *fallback_dlight_vp = "in vec3 attr_Position;\n"
"in vec2 attr_TexCoord0;\n"
"in vec3 attr_Normal;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int u_DeformType;\n"
"uniform int u_DeformFunc;\n"
"uniform float u_DeformParams[7];\n"
"uniform float u_Time;\n"
"#endif\n"
"\n"
"uniform vec4 u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"\n"
"uniform mat4 u_ModelMatrix;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec3 var_Normal;\n"
"out vec4 var_LightDirAndRadiusSq;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"float GetNoiseValue( float x, float y, float z, float t )\n"
"{\n"
"	// Variation on the 'one-liner random function'.\n"
"	// Not sure if this is still 'correctly' random\n"
"	return fract( sin( dot(\n"
"		vec4( x, y, z, t ),\n"
"		vec4( 12.9898, 78.233, 12.9898, 78.233 )\n"
"	)) * 43758.5453 );\n"
"}\n"
"\n"
"float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )\n"
"{\n"
"	float value = phase + time * frequency;\n"
"\n"
"	switch ( func )\n"
"	{\n"
"		case WF_SIN:\n"
"			return sin(value * 2.0 * M_PI);\n"
"		case WF_SQUARE:\n"
"			return sign(0.5 - fract(value));\n"
"		case WF_TRIANGLE:\n"
"			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"		case WF_SAWTOOTH:\n"
"			return fract(value);\n"
"		case WF_INVERSE_SAWTOOTH:\n"
"			return 1.0 - fract(value);\n"
"		default:\n"
"			return 0.0;\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"	switch ( u_DeformType )\n"
"	{\n"
"		default:\n"
"		{\n"
"			return pos;\n"
"		}\n"
"\n"
"		case DEFORM_BULGE:\n"
"		{\n"
"			float bulgeHeight = u_DeformParams[1]; // amplitude\n"
"			float bulgeWidth = u_DeformParams[2]; // phase\n"
"			float bulgeSpeed = u_DeformParams[3]; // frequency\n"
"\n"
"			float scale = CalculateDeformScale( WF_SIN, u_Time, bulgeWidth * st.x, bulgeSpeed );\n"
"\n"
"			return pos + normal * scale * bulgeHeight;\n"
"		}\n"
"\n"
"		case DEFORM_WAVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			float spread = u_DeformParams[4];\n"
"\n"
"			float offset = dot( pos.xyz, vec3( spread ) );\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase + offset, frequency );\n"
"\n"
"			return pos + normal * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_MOVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			vec3 direction = vec3( u_DeformParams[4], u_DeformParams[5], u_DeformParams[6] );\n"
"\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase, frequency );\n"
"\n"
"			return pos + direction * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_PROJECTION_SHADOW:\n"
"		{\n"
"			vec3 ground = vec3(\n"
"				u_DeformParams[0],\n"
"				u_DeformParams[1],\n"
"				u_DeformParams[2]);\n"
"			float groundDist = u_DeformParams[3];\n"
"			vec3 lightDir = vec3(\n"
"				u_DeformParams[4],\n"
"				u_DeformParams[5],\n"
"				u_DeformParams[6]);\n"
"\n"
"			float d = dot( lightDir, ground );\n"
"\n"
"			lightDir = lightDir * max( 0.5 - d, 0.0 ) + ground;\n"
"			d = 1.0 / dot( lightDir, ground );\n"
"\n"
"			vec3 lightPos = lightDir * d;\n"
"\n"
"			return pos - lightPos * dot( pos, ground ) + groundDist;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformNormal( const in vec3 position, const in vec3 normal )\n"
"{\n"
"	if ( u_DeformType != DEFORM_NORMALS )\n"
"	{\n"
"		return normal;\n"
"	}\n"
"\n"
"	float amplitude = u_DeformParams[1];\n"
"	float frequency = u_DeformParams[3];\n"
"\n"
"	vec3 outNormal = normal;\n"
"	const float scale = 0.98;\n"
"	\n"
"	outNormal.x += amplitude * GetNoiseValue(\n"
"		position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.y += amplitude * GetNoiseValue(\n"
"		100.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.z += amplitude * GetNoiseValue(\n"
"		200.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	return outNormal;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	vec3 position = attr_Position;\n"
"	vec3 normal = normalize(attr_Normal * 2.0 - vec3(1.0));\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"	position = DeformPosition(position, normal, attr_TexCoord0.st);\n"
"	normal = DeformNormal(position, normal);\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"	\n"
"	vec3 positionWS = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"	vec3 L = u_LightOrigin.xyz - positionWS;\n"
"	L = (u_ModelMatrix * vec4(L, 0.0)).xyz;\n"
"\n"
"	var_Normal = normalize((u_ModelMatrix * vec4(normal, 0.0)).xyz);\n"
"	var_LightDirAndRadiusSq = vec4(L, u_LightRadius * u_LightRadius);\n"
"}\n"
"\n"
"";
const char *fallback_dlight_fp = "uniform vec3 u_DirectedLight;\n"
"\n"
"in vec3 var_Normal;\n"
"in vec4 var_LightDirAndRadiusSq;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"float CalcLightAttenuation(float normDist)\n"
"{\n"
"	// zero light at 1.0, approximating q3 style\n"
"	// also don't attenuate directional light\n"
"	float attenuation = (0.5 * normDist - 1.5) + 1.0;\n"
"	return clamp(attenuation, 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float lightDistSq = dot(var_LightDirAndRadiusSq.xyz, var_LightDirAndRadiusSq.xyz);\n"
"	vec3  N           = normalize(var_Normal);\n"
"	vec3  L           = var_LightDirAndRadiusSq.xyz / sqrt(lightDistSq);\n"
"\n"
"	float attenuation = CalcLightAttenuation(var_LightDirAndRadiusSq.w / lightDistSq);\n"
"	float NL          = clamp(dot(N, L), 0.0, 1.0);\n"
"\n"
"	out_Color = vec4(NL * attenuation * u_DirectedLight, 1.0);\n"
"}\n"
"";
GPUShaderDesc fallback_dlightShaders[] = {
  { GPUSHADER_VERTEX, fallback_dlight_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_dlight_fp, 181 },
};
extern const GPUProgramDesc fallback_dlightProgram = { 2, fallback_dlightShaders };

const char *fallback_down4x_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_TexCoords = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_down4x_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec2 u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color;\n"
"	vec2 tc;\n"
"	\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-1.5, -1.5);  color  = texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-0.5, -1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 0.5, -1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 1.5, -1.5);  color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-1.5, -0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-0.5, -0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 0.5, -0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 1.5, -0.5); color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-1.5,  0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-0.5,  0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 0.5,  0.5); color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 1.5,  0.5); color += texture(u_TextureMap, tc);\n"
"\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-1.5,  1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2(-0.5,  1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 0.5,  1.5);  color += texture(u_TextureMap, tc);\n"
"	tc = var_TexCoords + u_InvTexRes * vec2( 1.5,  1.5);  color += texture(u_TextureMap, tc);\n"
"	\n"
"	color *= 0.0625;\n"
"	\n"
"	out_Color = color;\n"
"}\n"
"";
GPUShaderDesc fallback_down4xShaders[] = {
  { GPUSHADER_VERTEX, fallback_down4x_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_down4x_fp, 17 },
};
extern const GPUProgramDesc fallback_down4xProgram = { 2, fallback_down4xShaders };

const char *fallback_fogpass_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"\n"
"in vec2 attr_TexCoord0;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"in vec3 attr_Position2;\n"
"in vec3 attr_Normal2;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"in uvec4 attr_BoneIndexes;\n"
"in vec4 attr_BoneWeights;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int u_DeformType;\n"
"uniform int u_DeformFunc;\n"
"uniform float u_DeformParams[7];\n"
"#endif\n"
"\n"
"uniform float u_Time;\n"
"uniform mat4 u_ModelMatrix;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float u_VertexLerp;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"uniform mat4x3 u_BoneMatrices[20];\n"
"#endif\n"
"\n"
"uniform vec4 u_Color;\n"
"\n"
"out vec3 var_WSPosition;\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"float GetNoiseValue( float x, float y, float z, float t )\n"
"{\n"
"	// Variation on the 'one-liner random function'.\n"
"	// Not sure if this is still 'correctly' random\n"
"	return fract( sin( dot(\n"
"		vec4( x, y, z, t ),\n"
"		vec4( 12.9898, 78.233, 12.9898, 78.233 )\n"
"	)) * 43758.5453 );\n"
"}\n"
"\n"
"float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )\n"
"{\n"
"	float value = phase + time * frequency;\n"
"\n"
"	switch ( func )\n"
"	{\n"
"		case WF_SIN:\n"
"			return sin(value * 2.0 * M_PI);\n"
"		case WF_SQUARE:\n"
"			return sign(0.5 - fract(value));\n"
"		case WF_TRIANGLE:\n"
"			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"		case WF_SAWTOOTH:\n"
"			return fract(value);\n"
"		case WF_INVERSE_SAWTOOTH:\n"
"			return 1.0 - fract(value);\n"
"		default:\n"
"			return 0.0;\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"	switch ( u_DeformType )\n"
"	{\n"
"		default:\n"
"		{\n"
"			return pos;\n"
"		}\n"
"\n"
"		case DEFORM_BULGE:\n"
"		{\n"
"			float bulgeHeight = u_DeformParams[1]; // amplitude\n"
"			float bulgeWidth = u_DeformParams[2]; // phase\n"
"			float bulgeSpeed = u_DeformParams[3]; // frequency\n"
"\n"
"			float scale = CalculateDeformScale( WF_SIN, u_Time, bulgeWidth * st.x, bulgeSpeed );\n"
"\n"
"			return pos + normal * scale * bulgeHeight;\n"
"		}\n"
"\n"
"		case DEFORM_WAVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			float spread = u_DeformParams[4];\n"
"\n"
"			float offset = dot( pos.xyz, vec3( spread ) );\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase + offset, frequency );\n"
"\n"
"			return pos + normal * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_MOVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			vec3 direction = vec3( u_DeformParams[4], u_DeformParams[5], u_DeformParams[6] );\n"
"\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase, frequency );\n"
"\n"
"			return pos + direction * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_PROJECTION_SHADOW:\n"
"		{\n"
"			vec3 ground = vec3(\n"
"				u_DeformParams[0],\n"
"				u_DeformParams[1],\n"
"				u_DeformParams[2]);\n"
"			float groundDist = u_DeformParams[3];\n"
"			vec3 lightDir = vec3(\n"
"				u_DeformParams[4],\n"
"				u_DeformParams[5],\n"
"				u_DeformParams[6]);\n"
"\n"
"			float d = dot( lightDir, ground );\n"
"\n"
"			lightDir = lightDir * max( 0.5 - d, 0.0 ) + ground;\n"
"			d = 1.0 / dot( lightDir, ground );\n"
"\n"
"			vec3 lightPos = lightDir * d;\n"
"\n"
"			return pos - lightPos * dot( pos, ground ) + groundDist;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformNormal( const in vec3 position, const in vec3 normal )\n"
"{\n"
"	if ( u_DeformType != DEFORM_NORMALS )\n"
"	{\n"
"		return normal;\n"
"	}\n"
"\n"
"	float amplitude = u_DeformParams[1];\n"
"	float frequency = u_DeformParams[3];\n"
"\n"
"	vec3 outNormal = normal;\n"
"	const float scale = 0.98;\n"
"	\n"
"	outNormal.x += amplitude * GetNoiseValue(\n"
"		position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.y += amplitude * GetNoiseValue(\n"
"		100.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.z += amplitude * GetNoiseValue(\n"
"		200.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	return outNormal;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"	vec3 position = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"	vec3 normal   = mix(attr_Normal,   attr_Normal2,   u_VertexLerp);\n"
"	normal = normalize(normal - vec3(0.5));\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"	vec4 position4 = vec4(0.0);\n"
"	vec4 normal4 = vec4(0.0);\n"
"	vec4 originalPosition = vec4(attr_Position, 1.0);\n"
"	vec4 originalNormal = vec4(attr_Normal - vec3 (0.5), 0.0);\n"
"\n"
"	for (int i = 0; i < 4; i++)\n"
"	{\n"
"		uint boneIndex = attr_BoneIndexes[i];\n"
"\n"
"		mat4 boneMatrix = mat4(\n"
"			vec4(u_BoneMatrices[boneIndex][0], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][1], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][2], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][3], 1.0)\n"
"		);\n"
"\n"
"		position4 += (boneMatrix * originalPosition) * attr_BoneWeights[i];\n"
"		normal4 += (boneMatrix * originalNormal) * attr_BoneWeights[i];\n"
"	}\n"
"\n"
"	vec3 position = position4.xyz;\n"
"	vec3 normal = normalize(normal4.xyz);\n"
"#else\n"
"	vec3 position = attr_Position;\n"
"	vec3 normal   = attr_Normal * 2.0 - vec3(1.0);\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"	position = DeformPosition(position, normal, attr_TexCoord0.st);\n"
"	normal = DeformNormal( position, normal );\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"	var_WSPosition = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"}\n"
"\n"
"";
const char *fallback_fogpass_fp = "uniform vec4 u_Color;\n"
"#if defined(USE_ATEST)\n"
"uniform float u_AlphaTestValue;\n"
"#endif\n"
"\n"
"uniform vec4 u_FogPlane;\n"
"uniform float u_FogDepthToOpaque;\n"
"uniform bool u_FogHasPlane;\n"
"uniform vec3 u_ViewOrigin;\n"
"in vec3 var_WSPosition;\n"
"\n"
"out vec4 out_Color;\n"
"out vec4 out_Glow;\n"
"\n"
"float CalcFog(in vec3 viewOrigin, in vec3 position, in vec4 fogPlane, in float depthToOpaque, in bool hasPlane)\n"
"{\n"
"	// line: x = o + tv\n"
"	// plane: (x . n) + d = 0\n"
"	// intersects: dot(o + tv, n) + d = 0\n"
"	//             dot(o + tv, n) = -d\n"
"	//             dot(o, n) + t*dot(n, v) = -d\n"
"	//             t = -(d + dot(o, n)) / dot(n, v)\n"
"	vec3 V = position - viewOrigin;\n"
"\n"
"	// fogPlane is inverted in tr_bsp for some reason.\n"
"	float t = -(fogPlane.w + dot(viewOrigin, -fogPlane.xyz)) / dot(V, -fogPlane.xyz);\n"
"\n"
"	bool inFog = ((dot(viewOrigin, fogPlane.xyz) - fogPlane.w) >= 0.0) || !hasPlane;\n"
"	bool intersects = (t > 0.0 && t <= 1.0);\n"
"\n"
"	// this is valid only when t > 0.0. When t < 0.0, then intersection point is behind\n"
"	// the camera, meaning we're facing away from the fog plane, which probably means\n"
"	// we're inside the fog volume.\n"
"	vec3 intersectsAt = viewOrigin + t*V;\n"
"\n"
"	float distToVertexFromIntersection = distance(intersectsAt, position);\n"
"	float distToVertexFromViewOrigin = distance(viewOrigin, position);\n"
"\n"
"	float distToVertex = mix(distToVertexFromViewOrigin,\n"
"							 distToVertexFromIntersection,\n"
"							 !inFog && intersects);\n"
"\n"
"	float z = depthToOpaque * distToVertex;\n"
"	return 1.0 - clamp(exp(-(z * z)), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float fog = CalcFog(u_ViewOrigin, var_WSPosition, u_FogPlane, u_FogDepthToOpaque, u_FogHasPlane);\n"
"	out_Color.rgb = u_Color.rgb;\n"
"	out_Color.a = sqrt(clamp(fog, 0.0, 1.0));\n"
"\n"
"#if defined(USE_ATEST)\n"
"#  if USE_ATEST == ATEST_CMP_LT\n"
"	if (out_Color.a >= u_AlphaTestValue)\n"
"#  elif USE_ATEST == ATEST_CMP_GT\n"
"	if (out_Color.a <= u_AlphaTestValue)\n"
"#  elif USE_ATEST == ATEST_CMP_GE\n"
"	if (out_Color.a < u_AlphaTestValue)\n"
"#  endif\n"
"		discard;\n"
"#endif\n"
"\n"
"#if defined(USE_GLOW_BUFFER)\n"
"	out_Glow = out_Color;\n"
"#else\n"
"	out_Glow = vec4(0.0);\n"
"#endif\n"
"}\n"
"";
GPUShaderDesc fallback_fogpassShaders[] = {
  { GPUSHADER_VERTEX, fallback_fogpass_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_fogpass_fp, 218 },
};
extern const GPUProgramDesc fallback_fogpassProgram = { 2, fallback_fogpassShaders };

const char *fallback_gaussian_blur_vp = "out vec2 var_TexCoords;\n"
"\n"
"void main()\n"
"{\n"
"	const vec2 positions[4] = vec2[](\n"
"		vec2 (-1.0, -1.0),\n"
"		vec2 (1.0, -1.0),\n"
"		vec2 (1.0, 1.0),\n"
"		vec2 (-1.0, 1.0)\n"
"	);\n"
"\n"
"	const vec2 texcoords[4] = vec2[](\n"
"		vec2 (0.0, 0.0),\n"
"		vec2 (1.0, 0.0),\n"
"		vec2 (1.0, 1.0),\n"
"		vec2 (0.0, 1.0)\n"
"	);\n"
"\n"
"	gl_Position = vec4(positions[gl_VertexID], 0.0, 1.0);\n"
"	var_TexCoords = texcoords[gl_VertexID];\n"
"}\n"
"\n"
"";
const char *fallback_gaussian_blur_fp = "uniform sampler2D u_TextureMap;\n"
"uniform vec4  u_Color;\n"
"uniform vec2  u_InvTexRes;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"#define NUM_TAPS 3\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = vec4 (0.0);\n"
"\n"
"#if NUM_TAPS == 7\n"
"	const float weights[] = float[4](1.0 / 64.0, 6.0 / 64.0, 15.0 / 64.0, 20.0 / 64.0);\n"
"\n"
"#if defined(BLUR_X)\n"
"	color += texture (u_TextureMap, vec2 (-3.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"	color += texture (u_TextureMap, vec2 (-2.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 (-1.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[2];\n"
"	color += texture (u_TextureMap, vec2 ( 0.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[3];\n"
"	color += texture (u_TextureMap, vec2 ( 1.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[2];\n"
"	color += texture (u_TextureMap, vec2 ( 2.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 ( 3.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"#else\n"
"	color += texture (u_TextureMap, vec2 (0.0, -3.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"	color += texture (u_TextureMap, vec2 (0.0, -2.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 (0.0, -1.0) * u_InvTexRes + var_TexCoords) * weights[2];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  0.0) * u_InvTexRes + var_TexCoords) * weights[3];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  1.0) * u_InvTexRes + var_TexCoords) * weights[2];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  2.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  3.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"#endif\n"
"#elif NUM_TAPS == 3\n"
"	const float weights[] = float[2](0.25, 0.5);\n"
"\n"
"#if defined(BLUR_X)\n"
"	color += texture (u_TextureMap, vec2 (-1.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"	color += texture (u_TextureMap, vec2 ( 0.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 ( 1.0, 0.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"#else\n"
"	color += texture (u_TextureMap, vec2 (0.0, -1.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  0.0) * u_InvTexRes + var_TexCoords) * weights[1];\n"
"	color += texture (u_TextureMap, vec2 (0.0,  1.0) * u_InvTexRes + var_TexCoords) * weights[0];\n"
"#endif\n"
"#endif\n"
"\n"
"	out_Color = color * u_Color;\n"
"}";
GPUShaderDesc fallback_gaussian_blurShaders[] = {
  { GPUSHADER_VERTEX, fallback_gaussian_blur_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_gaussian_blur_fp, 25 },
};
extern const GPUProgramDesc fallback_gaussian_blurProgram = { 2, fallback_gaussian_blurShaders };

const char *fallback_generic_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"in vec3 attr_Position2;\n"
"in vec3 attr_Normal2;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"in uvec4 attr_BoneIndexes;\n"
"in vec4 attr_BoneWeights;\n"
"#endif\n"
"\n"
"in vec4 attr_Color;\n"
"in vec2 attr_TexCoord0;\n"
"\n"
"#if defined(USE_TCGEN)\n"
"in vec2 attr_TexCoord1;\n"
"#endif\n"
"\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_RGBAGEN)\n"
"uniform vec3 u_LocalViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"uniform int u_DeformType;\n"
"uniform int u_DeformFunc;\n"
"uniform float u_DeformParams[7];\n"
"uniform float u_Time;\n"
"#endif\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform mat4 u_ModelMatrix;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"\n"
"uniform vec3 u_ViewForward;\n"
"uniform float u_FXVolumetricBase;\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"uniform int u_ColorGen;\n"
"uniform int u_AlphaGen;\n"
"uniform vec3 u_AmbientLight;\n"
"uniform vec3 u_DirectedLight;\n"
"uniform vec3 u_ModelLightDir;\n"
"uniform float u_PortalRange;\n"
"#endif\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float u_VertexLerp;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"uniform mat4x3 u_BoneMatrices[20];\n"
"#endif\n"
"\n"
"out vec2 var_DiffuseTex;\n"
"out vec4 var_Color;\n"
"#if defined(USE_FOG)\n"
"out vec3 var_WSPosition;\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"float GetNoiseValue( float x, float y, float z, float t )\n"
"{\n"
"	// Variation on the 'one-liner random function'.\n"
"	// Not sure if this is still 'correctly' random\n"
"	return fract( sin( dot(\n"
"		vec4( x, y, z, t ),\n"
"		vec4( 12.9898, 78.233, 12.9898, 78.233 )\n"
"	)) * 43758.5453 );\n"
"}\n"
"\n"
"float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )\n"
"{\n"
"	float value = phase + time * frequency;\n"
"\n"
"	switch ( func )\n"
"	{\n"
"		case WF_SIN:\n"
"			return sin(value * 2.0 * M_PI);\n"
"		case WF_SQUARE:\n"
"			return sign(0.5 - fract(value));\n"
"		case WF_TRIANGLE:\n"
"			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"		case WF_SAWTOOTH:\n"
"			return fract(value);\n"
"		case WF_INVERSE_SAWTOOTH:\n"
"			return 1.0 - fract(value);\n"
"		default:\n"
"			return 0.0;\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"	switch ( u_DeformType )\n"
"	{\n"
"		default:\n"
"		{\n"
"			return pos;\n"
"		}\n"
"\n"
"		case DEFORM_BULGE:\n"
"		{\n"
"			float bulgeHeight = u_DeformParams[1]; // amplitude\n"
"			float bulgeWidth = u_DeformParams[2]; // phase\n"
"			float bulgeSpeed = u_DeformParams[3]; // frequency\n"
"\n"
"			float scale = CalculateDeformScale( WF_SIN, u_Time, bulgeWidth * st.x, bulgeSpeed );\n"
"\n"
"			return pos + normal * scale * bulgeHeight;\n"
"		}\n"
"\n"
"		case DEFORM_WAVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			float spread = u_DeformParams[4];\n"
"\n"
"			float offset = dot( pos.xyz, vec3( spread ) );\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase + offset, frequency );\n"
"\n"
"			return pos + normal * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_MOVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			vec3 direction = vec3( u_DeformParams[4], u_DeformParams[5], u_DeformParams[6] );\n"
"\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase, frequency );\n"
"\n"
"			return pos + direction * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_PROJECTION_SHADOW:\n"
"		{\n"
"			vec3 ground = vec3(\n"
"				u_DeformParams[0],\n"
"				u_DeformParams[1],\n"
"				u_DeformParams[2]);\n"
"			float groundDist = u_DeformParams[3];\n"
"			vec3 lightDir = vec3(\n"
"				u_DeformParams[4],\n"
"				u_DeformParams[5],\n"
"				u_DeformParams[6]);\n"
"\n"
"			float d = dot( lightDir, ground );\n"
"\n"
"			if (d < 0.5)\n"
"				lightDir = lightDir + (max( 0.5 - d, 0.0 ) * ground);\n"
"\n"
"			d = 1.0 / dot( lightDir, ground );\n"
"\n"
"			vec3 lightPos = lightDir * d;\n"
"\n"
"			return pos - (lightPos * (dot( pos, ground ) + groundDist));\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformNormal( const in vec3 position, const in vec3 normal )\n"
"{\n"
"	if ( u_DeformType != DEFORM_NORMALS )\n"
"	{\n"
"		return normal;\n"
"	}\n"
"\n"
"	float amplitude = u_DeformParams[1];\n"
"	float frequency = u_DeformParams[3];\n"
"\n"
"	vec3 outNormal = normal;\n"
"	const float scale = 0.98;\n"
"	\n"
"	outNormal.x += amplitude * GetNoiseValue(\n"
"		position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.y += amplitude * GetNoiseValue(\n"
"		100.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.z += amplitude * GetNoiseValue(\n"
"		200.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	return outNormal;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"	vec2 tex = attr_TexCoord0.st;\n"
"\n"
"	if (TCGen >= TCGEN_LIGHTMAP && TCGen <= TCGEN_LIGHTMAP3)\n"
"	{\n"
"		tex = attr_TexCoord1.st;\n"
"	}\n"
"	else if (TCGen == TCGEN_ENVIRONMENT_MAPPED)\n"
"	{\n"
"		vec3 viewer = normalize(u_LocalViewOrigin - position);\n"
"		vec2 ref = reflect(viewer, normal).yz;\n"
"		tex.s = ref.x * -0.5 + 0.5;\n"
"		tex.t = ref.y *  0.5 + 0.5;\n"
"	}\n"
"	else if (TCGen == TCGEN_VECTOR)\n"
"	{\n"
"		tex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"	}\n"
"	\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"	st2.x = st.x * texMatrix.x + (st.y * texMatrix.z + offTurb.x);\n"
"	st2.y = st.x * texMatrix.y + (st.y * texMatrix.w + offTurb.y);\n"
"\n"
"	vec2 offsetPos = vec2(position.x + position.z, position.y);\n"
"	\n"
"	vec2 texOffset = sin(offsetPos * (2.0 * M_PI / 1024.0) + vec2(phase));\n"
"	\n"
"	return st2 + texOffset * amplitude;	\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_RGBAGEN)\n"
"vec4 CalcColor(vec3 position, vec3 normal)\n"
"{\n"
"	vec4 color = u_VertColor * attr_Color + u_BaseColor;\n"
"	\n"
"	if (u_ColorGen == CGEN_LIGHTING_DIFFUSE)\n"
"	{\n"
"		float incoming = clamp(dot(normal, u_ModelLightDir), 0.0, 1.0);\n"
"\n"
"		color.rgb = clamp(u_DirectedLight * incoming + u_AmbientLight, 0.0, 1.0);\n"
"	}\n"
"	\n"
"	vec3 viewer = u_LocalViewOrigin - position;\n"
"\n"
"	if (u_AlphaGen == AGEN_LIGHTING_SPECULAR)\n"
"	{\n"
"		vec3 lightDir = normalize(vec3(-960.0, 1980.0, 96.0) - position);\n"
"		vec3 reflected = -reflect(lightDir, normal);\n"
"		\n"
"		color.a = clamp(dot(reflected, normalize(viewer)), 0.0, 1.0);\n"
"		color.a *= color.a;\n"
"		color.a *= color.a;\n"
"	}\n"
"	else if (u_AlphaGen == AGEN_PORTAL)\n"
"	{\n"
"		color.a = clamp(length(viewer) / u_PortalRange, 0.0, 1.0);\n"
"	}\n"
"	\n"
"	return color;\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"	vec3 position  = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"	vec3 normal    = mix(attr_Normal,   attr_Normal2,   u_VertexLerp);\n"
"	normal = normalize(normal - vec3(0.5));\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"	vec4 position4 = vec4(0.0);\n"
"	vec4 normal4 = vec4(0.0);\n"
"	vec4 originalPosition = vec4(attr_Position, 1.0);\n"
"	vec4 originalNormal = vec4(attr_Normal - vec3 (0.5), 0.0);\n"
"\n"
"	for (int i = 0; i < 4; i++)\n"
"	{\n"
"		uint boneIndex = attr_BoneIndexes[i];\n"
"\n"
"		mat4 boneMatrix = mat4(\n"
"			vec4(u_BoneMatrices[boneIndex][0], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][1], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][2], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][3], 1.0)\n"
"		);\n"
"\n"
"		position4 += (boneMatrix * originalPosition) * attr_BoneWeights[i];\n"
"		normal4 += (boneMatrix * originalNormal) * attr_BoneWeights[i];\n"
"	}\n"
"\n"
"	vec3 position = position4.xyz;\n"
"	vec3 normal = normalize(normal4.xyz);\n"
"#else\n"
"	vec3 position  = attr_Position;\n"
"	vec3 normal    = attr_Normal * 2.0 - vec3(1.0);\n"
"#endif\n"
"\n"
"#if defined(USE_DEFORM_VERTEXES)\n"
"	position = DeformPosition(position, normal, attr_TexCoord0.st);\n"
"	normal = DeformNormal( position, normal );\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 tex = GenTexCoords(u_TCGen0, position, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"	vec2 tex = attr_TexCoord0.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	var_DiffuseTex = ModTexCoords(tex, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"    var_DiffuseTex = tex;\n"
"#endif\n"
"\n"
"	if ( u_FXVolumetricBase >= 0.0 )\n"
"	{\n"
"		vec3 viewForward = u_ViewForward;\n"
"		float d = clamp(dot(normalize(viewForward), normalize(normal)), 0.0, 1.0);\n"
"		d = d * d;\n"
"		d = d * d;\n"
"\n"
"		var_Color = vec4(u_FXVolumetricBase * (1.0 - d));\n"
"	}\n"
"	else\n"
"	{\n"
"#if defined(USE_RGBAGEN)\n"
"		var_Color = CalcColor(position, normal);\n"
"#else\n"
"		var_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"#endif\n"
"	}\n"
"\n"
"#if defined(USE_FOG)\n"
"	var_WSPosition = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"#endif\n"
"}\n"
"\n"
"\n"
"";
const char *fallback_generic_fp = "uniform sampler2D u_DiffuseMap;\n"
"#if defined(USE_ATEST)\n"
"uniform float u_AlphaTestValue;\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"uniform vec4 u_FogPlane;\n"
"uniform float u_FogDepthToOpaque;\n"
"uniform bool u_FogHasPlane;\n"
"uniform vec3 u_ViewOrigin;\n"
"uniform vec4 u_FogColorMask;\n"
"#endif\n"
"\n"
"in vec2 var_DiffuseTex;\n"
"in vec4 var_Color;\n"
"#if defined(USE_FOG)\n"
"in vec3 var_WSPosition;\n"
"#endif\n"
"\n"
"out vec4 out_Color;\n"
"out vec4 out_Glow;\n"
"\n"
"\n"
"#if defined(USE_FOG)\n"
"float CalcFog(in vec3 viewOrigin, in vec3 position, in vec4 fogPlane, in float depthToOpaque, in bool hasPlane)\n"
"{\n"
"	// line: x = o + tv\n"
"	// plane: (x . n) + d = 0\n"
"	// intersects: dot(o + tv, n) + d = 0\n"
"	//             dot(o + tv, n) = -d\n"
"	//             dot(o, n) + t*dot(n, v) = -d\n"
"	//             t = -(d + dot(o, n)) / dot(n, v)\n"
"	vec3 V = position - viewOrigin;\n"
"\n"
"	// fogPlane is inverted in tr_bsp for some reason.\n"
"	float t = -(fogPlane.w + dot(viewOrigin, -fogPlane.xyz)) / dot(V, -fogPlane.xyz);\n"
"\n"
"	bool inFog = ((dot(viewOrigin, fogPlane.xyz) - fogPlane.w) >= 0.0) || !hasPlane;\n"
"	bool intersects = (t > 0.0 && t <= 1.0);\n"
"\n"
"	// this is valid only when t > 0.0. When t < 0.0, then intersection point is behind\n"
"	// the camera, meaning we're facing away from the fog plane, which probably means\n"
"	// we're inside the fog volume.\n"
"	vec3 intersectsAt = viewOrigin + t*V;\n"
"\n"
"	float distToVertexFromIntersection = distance(intersectsAt, position);\n"
"	float distToVertexFromViewOrigin = distance(viewOrigin, position);\n"
"\n"
"	float distToVertex = mix(distToVertexFromViewOrigin,\n"
"							 distToVertexFromIntersection,\n"
"							 !inFog && intersects);\n"
"\n"
"	return min(distToVertex / depthToOpaque, 1.0);\n"
"}\n"
"#endif\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color  = texture(u_DiffuseMap, var_DiffuseTex);\n"
"\n"
"#if defined(USE_ATEST)\n"
"#  if USE_ATEST == ATEST_CMP_LT\n"
"	if (color.a >= u_AlphaTestValue)\n"
"#  elif USE_ATEST == ATEST_CMP_GT\n"
"	if (color.a <= u_AlphaTestValue)\n"
"#  elif USE_ATEST == ATEST_CMP_GE\n"
"	if (color.a < u_AlphaTestValue)\n"
"#  endif\n"
"		discard;\n"
"#endif\n"
"\n"
"#if defined(USE_FOG)\n"
"	float fog = CalcFog(u_ViewOrigin, var_WSPosition, u_FogPlane, u_FogDepthToOpaque, u_FogHasPlane);\n"
"	color *= vec4(1.0) - u_FogColorMask * fog;\n"
"#endif\n"
"\n"
"	out_Color = color * var_Color;\n"
"\n"
"#if defined(USE_GLOW_BUFFER)\n"
"	out_Glow = out_Color;\n"
"#else\n"
"	out_Glow = vec4(0.0);\n"
"#endif\n"
"}\n"
"";
GPUShaderDesc fallback_genericShaders[] = {
  { GPUSHADER_VERTEX, fallback_generic_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_generic_fp, 361 },
};
extern const GPUProgramDesc fallback_genericProgram = { 2, fallback_genericShaders };

const char *fallback_lightall_vp = "#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#define PER_PIXEL_LIGHTING\n"
"#endif\n"
"in vec2 attr_TexCoord0;\n"
"#if defined(USE_LIGHTMAP) || defined(USE_TCGEN)\n"
"in vec2 attr_TexCoord1;\n"
"in vec2 attr_TexCoord2;\n"
"in vec2 attr_TexCoord3;\n"
"in vec2 attr_TexCoord4;\n"
"#endif\n"
"in vec4 attr_Color;\n"
"\n"
"in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"in vec4 attr_Tangent;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"in vec3 attr_Position2;\n"
"in vec3 attr_Normal2;\n"
"in vec4 attr_Tangent2;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"in uvec4 attr_BoneIndexes;\n"
"in vec4 attr_BoneWeights;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT) && !defined(USE_LIGHT_VECTOR)\n"
"in vec3 attr_LightDirection;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform vec4   u_EnableTextures; // x = normal, y = deluxe, z = specular, w = cube\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"uniform vec3 u_ViewOrigin;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_LIGHTMAP)\n"
"uniform int u_TCGen0;\n"
"uniform vec3 u_TCGen0Vector0;\n"
"uniform vec3 u_TCGen0Vector1;\n"
"uniform vec3 u_LocalViewOrigin;\n"
"uniform int u_TCGen1;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"uniform vec4 u_DiffuseTexMatrix;\n"
"uniform vec4 u_DiffuseTexOffTurb;\n"
"#endif\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform vec4 u_BaseColor;\n"
"uniform vec4 u_VertColor;\n"
"uniform mat4 u_ModelMatrix;\n"
"\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"uniform float u_VertexLerp;\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"uniform mat4x3 u_BoneMatrices[20];\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"uniform vec4 u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"uniform vec3 u_DirectedLight;\n"
"uniform vec3 u_AmbientLight;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec4 u_PrimaryLightOrigin;\n"
"uniform float u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"uniform vec3 u_ViewForward;\n"
"uniform float u_FXVolumetricBase;\n"
"\n"
"out vec4 var_TexCoords;\n"
"out vec4 var_Color;\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"out vec3 var_Position;\n"
"out vec4 var_Normal;\n"
"out vec4 var_Tangent;\n"
"out vec4 var_Bitangent;\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"out vec4 var_LightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"out vec4 var_PrimaryLightDir;\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN) || defined(USE_LIGHTMAP)\n"
"vec2 GenTexCoords(int TCGen, vec3 position, vec3 normal, vec3 TCGenVector0, vec3 TCGenVector1)\n"
"{\n"
"	vec2 tex = attr_TexCoord0;\n"
"\n"
"	switch (TCGen)\n"
"	{\n"
"		case TCGEN_LIGHTMAP:\n"
"			tex = attr_TexCoord1;\n"
"		break;\n"
"\n"
"		case TCGEN_LIGHTMAP1:\n"
"			tex = attr_TexCoord2;\n"
"		break;\n"
"\n"
"		case TCGEN_LIGHTMAP2:\n"
"			tex = attr_TexCoord3;\n"
"		break;\n"
"\n"
"		case TCGEN_LIGHTMAP3:\n"
"			tex = attr_TexCoord4;\n"
"		break;\n"
"\n"
"		case TCGEN_ENVIRONMENT_MAPPED:\n"
"		{\n"
"			vec3 viewer = normalize(u_LocalViewOrigin - position);\n"
"			vec2 ref = reflect(viewer, normal).yz;\n"
"			tex.s = ref.x * -0.5 + 0.5;\n"
"			tex.t = ref.y *  0.5 + 0.5;\n"
"		}\n"
"		break;\n"
"\n"
"		case TCGEN_VECTOR:\n"
"		{\n"
"			tex = vec2(dot(position, TCGenVector0), dot(position, TCGenVector1));\n"
"		}\n"
"		break;\n"
"	}\n"
"\n"
"	return tex;\n"
"}\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"vec2 ModTexCoords(vec2 st, vec3 position, vec4 texMatrix, vec4 offTurb)\n"
"{\n"
"	float amplitude = offTurb.z;\n"
"	float phase = offTurb.w * 2.0 * M_PI;\n"
"	vec2 st2;\n"
"	st2.x = st.x * texMatrix.x + (st.y * texMatrix.z + offTurb.x);\n"
"	st2.y = st.x * texMatrix.y + (st.y * texMatrix.w + offTurb.y);\n"
"\n"
"	vec2 offsetPos = vec2(position.x + position.z, position.y);\n"
"\n"
"	vec2 texOffset = sin(offsetPos * (2.0 * M_PI / 1024.0) + vec2(phase));\n"
"\n"
"	return st2 + texOffset * amplitude;	\n"
"}\n"
"#endif\n"
"\n"
"\n"
"float CalcLightAttenuation(float distance, float radius)\n"
"{\n"
"	float d = pow(distance / radius, 4.0);\n"
"	float attenuation = clamp(1.0 - d, 0.0, 1.0);\n"
"	attenuation *= attenuation;\n"
"	attenuation /= distance * distance + 1.0;\n"
"	// don't attenuate directional light\n"
"	attenuation = attenuation + float(radius < 1.0);\n"
"\n"
"	return clamp(attenuation, 0.0, 1.0);\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"#if defined(USE_VERTEX_ANIMATION)\n"
"	vec3 position  = mix(attr_Position,    attr_Position2,    u_VertexLerp);\n"
"	vec3 normal    = mix(attr_Normal,      attr_Normal2,      u_VertexLerp);\n"
"	vec3 tangent   = mix(attr_Tangent.xyz, attr_Tangent2.xyz, u_VertexLerp);\n"
"#elif defined(USE_SKELETAL_ANIMATION)\n"
"	vec4 position4 = vec4(0.0);\n"
"	vec4 normal4 = vec4(0.0);\n"
"	vec4 originalPosition = vec4(attr_Position, 1.0);\n"
"	vec4 originalNormal = vec4(attr_Normal - vec3 (0.5), 0.0);\n"
"	#if defined(PER_PIXEL_LIGHTING)\n"
"		vec4 tangent4 = vec4(0.0);\n"
"		vec4 originalTangent = vec4(attr_Tangent.xyz - vec3(0.5), 0.0);\n"
"	#endif\n"
"\n"
"	for (int i = 0; i < 4; i++)\n"
"	{\n"
"		uint boneIndex = attr_BoneIndexes[i];\n"
"\n"
"		mat4 boneMatrix = mat4(\n"
"			vec4(u_BoneMatrices[boneIndex][0], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][1], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][2], 0.0),\n"
"			vec4(u_BoneMatrices[boneIndex][3], 1.0)\n"
"		);\n"
"\n"
"		position4 += (boneMatrix * originalPosition) * attr_BoneWeights[i];\n"
"		normal4 += (boneMatrix * originalNormal) * attr_BoneWeights[i];\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"		tangent4 += (boneMatrix * originalTangent) * attr_BoneWeights[i];\n"
"#endif\n"
"	}\n"
"\n"
"	vec3 position = position4.xyz;\n"
"	vec3 normal = normalize (normal4.xyz);\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	vec3 tangent = normalize (tangent4.xyz);\n"
"#endif\n"
"#else\n"
"	vec3 position  = attr_Position;\n"
"	vec3 normal    = attr_Normal;\n"
"  #if defined(PER_PIXEL_LIGHTING)\n"
"	vec3 tangent   = attr_Tangent.xyz;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if !defined(USE_SKELETAL_ANIMATION)\n"
"	normal  = normal  * 2.0 - vec3(1.0);\n"
"  #if defined(PER_PIXEL_LIGHTING)\n"
"	tangent = tangent * 2.0 - vec3(1.0);\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(USE_TCGEN)\n"
"	vec2 texCoords = GenTexCoords(u_TCGen0, position, normal, u_TCGen0Vector0, u_TCGen0Vector1);\n"
"#else\n"
"	vec2 texCoords = attr_TexCoord0.st;\n"
"#endif\n"
"\n"
"#if defined(USE_TCMOD)\n"
"	var_TexCoords.xy = ModTexCoords(texCoords, position, u_DiffuseTexMatrix, u_DiffuseTexOffTurb);\n"
"#else\n"
"	var_TexCoords.xy = texCoords;\n"
"#endif\n"
"\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"\n"
"	position  = (u_ModelMatrix * vec4(position, 1.0)).xyz;\n"
"	normal    = (u_ModelMatrix * vec4(normal,   0.0)).xyz;\n"
"  #if defined(PER_PIXEL_LIGHTING)\n"
"	tangent   = (u_ModelMatrix * vec4(tangent,  0.0)).xyz;\n"
"  #endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	vec3 bitangent = cross(normal, tangent) * (attr_Tangent.w * 2.0 - 1.0);\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR)\n"
"	vec3 L = u_LightOrigin.xyz - (position * u_LightOrigin.w);\n"
"#elif defined(PER_PIXEL_LIGHTING)\n"
"	vec3 L = attr_LightDirection * 2.0 - vec3(1.0);\n"
"	L = (u_ModelMatrix * vec4(L, 0.0)).xyz;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"	var_TexCoords.zw = GenTexCoords(u_TCGen1, vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n"
"#endif\n"
"\n"
"	if ( u_FXVolumetricBase > 0.0 )\n"
"	{\n"
"		vec3 viewForward = u_ViewForward;\n"
"\n"
"		float d = clamp(dot(normalize(viewForward), normalize(normal)), 0.0, 1.0);\n"
"		d = d * d;\n"
"		d = d * d;\n"
"\n"
"		var_Color = vec4(u_FXVolumetricBase * (1.0 - d));\n"
"	}\n"
"	else\n"
"	{\n"
"		var_Color = u_VertColor * attr_Color + u_BaseColor;\n"
"\n"
"#if defined(USE_LIGHT_VECTOR) && defined(USE_FAST_LIGHT)\n"
"		float lightDist = length(L);\n"
"		float attenuation = CalcLightAttenuation(lightDist, u_LightRadius);\n"
"		float NL = clamp(dot(normalize(normal), L) / lightDist, 0.0, 1.0);\n"
"\n"
"		var_Color.rgb *= u_DirectedLight * (u_LightRadius + float(u_LightRadius < 1.0)) * (attenuation * NL) + u_AmbientLight;\n"
"#endif\n"
"	}\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"	var_PrimaryLightDir.xyz = u_PrimaryLightOrigin.xyz - (position * u_PrimaryLightOrigin.w);\n"
"	var_PrimaryLightDir.w = u_PrimaryLightRadius * u_PrimaryLightRadius;\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"	var_LightDir = vec4(L, u_LightRadius);\n"
"  #else\n"
"	var_LightDir = vec4(L, 0.0);\n"
"  #endif\n"
"  #if defined(USE_DELUXEMAP)\n"
"	var_LightDir -= u_EnableTextures.y * var_LightDir;\n"
"  #endif\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	vec3 viewDir = u_ViewOrigin - position;\n"
"	var_Position = position;\n"
"	// store view direction in tangent space to save on outs\n"
"	var_Normal    = vec4(normal,    viewDir.x);\n"
"	var_Tangent   = vec4(tangent,   viewDir.y);\n"
"	var_Bitangent = vec4(bitangent, viewDir.z);\n"
"#endif\n"
"}\n"
"\n"
"";
const char *fallback_lightall_fp = "#if defined(USE_LIGHT) && !defined(USE_FAST_LIGHT)\n"
"#define PER_PIXEL_LIGHTING\n"
"#endif\n"
"\n"
"uniform sampler2D u_DiffuseMap;\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"uniform sampler2D u_LightMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"uniform sampler2D u_NormalMap;\n"
"#endif\n"
"\n"
"#if defined(USE_DELUXEMAP)\n"
"uniform sampler2D u_DeluxeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SPECULARMAP)\n"
"uniform sampler2D u_SpecularMap;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOWMAP)\n"
"uniform sampler2D u_ShadowMap;\n"
"#endif\n"
"\n"
"#if defined(USE_CUBEMAP)\n"
"uniform samplerCube u_CubeMap;\n"
"#endif\n"
"\n"
"#if defined(USE_NORMALMAP) || defined(USE_DELUXEMAP) || defined(USE_SPECULARMAP) || defined(USE_CUBEMAP)\n"
"// x = normal, y = deluxe, z = specular, w = cube\n"
"uniform vec4      u_EnableTextures; \n"
"#endif\n"
"\n"
"#if defined(USE_LIGHT_VECTOR) && !defined(USE_FAST_LIGHT)\n"
"uniform vec3 u_DirectedLight;\n"
"uniform vec3 u_AmbientLight;\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"uniform vec3  u_PrimaryLightColor;\n"
"uniform vec3  u_PrimaryLightAmbient;\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"uniform vec4      u_NormalScale;\n"
"uniform vec4      u_SpecularScale;\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"#if defined(USE_CUBEMAP)\n"
"uniform vec4      u_CubeMapInfo;\n"
"uniform sampler2D u_EnvBrdfMap;\n"
"#endif\n"
"#endif\n"
"\n"
"#if defined(USE_ATEST)\n"
"uniform float u_AlphaTestValue;\n"
"#endif\n"
"\n"
"in vec4      var_TexCoords;\n"
"in vec4      var_Color;\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"in vec4   var_Normal;\n"
"in vec4   var_Tangent;\n"
"in vec4   var_Bitangent;\n"
"in vec4   var_LightDir;\n"
"\n"
"in vec3	  var_Position;\n"
"\n"
"uniform sampler3D u_LightGridDirectionMap;\n"
"uniform sampler3D u_LightGridDirectionalLightMap;\n"
"uniform sampler3D u_LightGridAmbientLightMap;\n"
"uniform vec3 u_LightGridOrigin;\n"
"uniform vec3 u_LightGridCellInverseSize;\n"
"uniform vec3 u_StyleColor;\n"
"uniform vec2 u_LightGridLightScale;\n"
"\n"
"#define u_LightGridAmbientScale u_LightGridLightScale.x\n"
"#define u_LightGridDirectionalScale u_LightGridLightScale.y\n"
"#endif\n"
"\n"
"#if defined(USE_PRIMARY_LIGHT) || defined(USE_SHADOWMAP)\n"
"in vec4      var_PrimaryLightDir;\n"
"#endif\n"
"\n"
"out vec4 out_Color;\n"
"out vec4 out_Glow;\n"
"\n"
"#define EPSILON 0.00000001\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"float SampleDepth(sampler2D normalMap, vec2 t)\n"
"{\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"	return 1.0 - texture(normalMap, t).r;\n"
"  #else\n"
"	return 1.0 - texture(normalMap, t).a;\n"
"  #endif\n"
"}\n"
"\n"
"float RayIntersectDisplaceMap(vec2 dp, vec2 ds, sampler2D normalMap)\n"
"{\n"
"	const int linearSearchSteps = 16;\n"
"	const int binarySearchSteps = 6;\n"
"\n"
"	// current size of search window\n"
"	float size = 1.0 / float(linearSearchSteps);\n"
"\n"
"	// current depth position\n"
"	float depth = 0.0;\n"
"\n"
"	// best match found (starts with last position 1.0)\n"
"	float bestDepth = 1.0;\n"
"\n"
"	// texture depth at best depth\n"
"	float texDepth = 0.0;\n"
"\n"
"	float prevT = SampleDepth(normalMap, dp);\n"
"	float prevTexDepth = prevT;\n"
"\n"
"	// search front to back for first point inside object\n"
"	for(int i = 0; i < linearSearchSteps - 1; ++i)\n"
"	{\n"
"		depth += size;\n"
"		\n"
"		float t = SampleDepth(normalMap, dp + ds * depth);\n"
"		\n"
"		if(bestDepth > 0.996)		// if no depth found yet\n"
"			if(depth >= t)\n"
"			{\n"
"				bestDepth = depth;	// store best depth\n"
"				texDepth = t;\n"
"				prevTexDepth = prevT;\n"
"			}\n"
"		prevT = t;\n"
"	}\n"
"\n"
"	depth = bestDepth;\n"
"\n"
"#if !defined (USE_RELIEFMAP)\n"
"	float div = 1.0 / (1.0 + (prevTexDepth - texDepth) * float(linearSearchSteps));\n"
"	bestDepth -= (depth - size - prevTexDepth) * div;\n"
"#else\n"
"	// recurse around first point (depth) for closest match\n"
"	for(int i = 0; i < binarySearchSteps; ++i)\n"
"	{\n"
"		size *= 0.5;\n"
"\n"
"		float t = SampleDepth(normalMap, dp + ds * depth);\n"
"		\n"
"		if(depth >= t)\n"
"		{\n"
"			bestDepth = depth;\n"
"			depth -= 2.0 * size;\n"
"		}\n"
"\n"
"		depth += size;\n"
"	}\n"
"#endif\n"
"\n"
"	return bestDepth;\n"
"}\n"
"#endif\n"
"\n"
"vec3 EnvironmentBRDF(float roughness, float NE, vec3 specular)\n"
"{\n"
"	// from http://community.arm.com/servlet/JiveServlet/download/96891546-19496/siggraph2015-mmg-renaldas-slides.pdf\n"
"	float v = 1.0 - max(roughness, NE);\n"
"	v *= v * v;\n"
"	return vec3(v) + specular;\n"
"}\n"
"\n"
"float spec_D(\n"
"  float NH,\n"
"  float roughness)\n"
"{\n"
"  // normal distribution\n"
"  // from http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n"
"  float alpha = roughness * roughness;\n"
"  float quotient = alpha / max(1e-8,(NH*NH*(alpha*alpha-1.0)+1.0));\n"
"  return (quotient * quotient) / M_PI;\n"
"}\n"
"\n"
"vec3 spec_F(\n"
"  float EH,\n"
"  vec3 F0)\n"
"{\n"
"  // Fresnel\n"
"  // from http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n"
"  float pow2 = pow(2.0, (-5.55473*EH - 6.98316) * EH);\n"
"  return F0 + (vec3(1.0) - F0) * pow2;\n"
"}\n"
"\n"
"vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n"
"{\n"
"    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n"
"} \n"
"\n"
"float G1(\n"
"  float NV,\n"
"  float k)\n"
"{\n"
"  return NV / (NV*(1.0-k) +  k);\n"
"}\n"
"\n"
"float spec_G(float NL, float NE, float roughness )\n"
"{\n"
"  // GXX Schlick\n"
"  // from http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n"
"  float k = max(((roughness + 1.0) * (roughness + 1.0)) / 8.0, 1e-5);\n"
"  return G1(NL,k)*G1(NE,k);\n"
"}\n"
"\n"
"vec3 CalcDiffuse(vec3 diffuseAlbedo, float NH, float EH, float roughness)\n"
"{\n"
"#if defined(USE_BURLEY)\n"
"	// modified from https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n"
"	float fd90 = -0.5 + EH * EH * roughness;\n"
"	float burley = 1.0 + fd90 * 0.04 / NH;\n"
"	burley *= burley;\n"
"	return diffuseAlbedo * burley;\n"
"#else\n"
"	return diffuseAlbedo;\n"
"#endif\n"
"}\n"
"\n"
"vec3 CalcSpecular(\n"
"	in vec3 specular,\n"
"	in float NH,\n"
"	in float NL,\n"
"	in float NE,\n"
"	in float EH,\n"
"	in float roughness\n"
")\n"
"{\n"
"	float distrib = spec_D(NH,roughness);\n"
"	vec3 fresnel = spec_F(EH,specular);\n"
"	float vis = spec_G(NL, NE, roughness);\n"
"	float denominator = max((4.0 * max(NE,0.0) * max(NL,0.0)),0.001);\n"
"	return (distrib * fresnel * vis) / denominator;\n"
"}\n"
"\n"
"float CalcLightAttenuation(float distance, float radius)\n"
"{\n"
"	float d = pow(distance / radius, 4.0);\n"
"	float attenuation = clamp(1.0 - d, 0.0, 1.0);\n"
"	attenuation *= attenuation;\n"
"	attenuation /= distance * distance + 1.0;\n"
"	// don't attenuate directional light\n"
"	attenuation = attenuation + float(radius < 1.0);\n"
"\n"
"	return clamp(attenuation, 0.0, 1.0);\n"
"}\n"
"\n"
"vec3 CalcNormal( in vec3 vertexNormal, in vec2 texCoords, in mat3 tangentToWorld )\n"
"{\n"
"	vec3 N = vertexNormal;\n"
"\n"
"#if defined(USE_NORMALMAP)\n"
"  #if defined(SWIZZLE_NORMALMAP)\n"
"	N.xy = texture(u_NormalMap, texCoords).ag - vec2(0.5);\n"
"  #else\n"
"	N.xy = texture(u_NormalMap, texCoords).rg - vec2(0.5);\n"
"  #endif\n"
"\n"
"	N.xy *= u_NormalScale.xy;\n"
"	N.z = sqrt(clamp((0.25 - N.x * N.x) - N.y * N.y, 0.0, 1.0));\n"
"	N = tangentToWorld * N;\n"
"#endif\n"
"\n"
"	return normalize(N);\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	vec3 viewDir, lightColor, ambientColor, reflectance, vertexColor, position;\n"
"	vec3 L, N, E, H;\n"
"	float NL, NH, NE, EH, attenuation;\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	mat3 tangentToWorld = mat3(var_Tangent.xyz, var_Bitangent.xyz, var_Normal.xyz);\n"
"	viewDir = vec3(var_Normal.w, var_Tangent.w, var_Bitangent.w);\n"
"	E = normalize(viewDir);\n"
"\n"
"	position = var_Position;\n"
"	ivec3 gridSize = textureSize(u_LightGridDirectionalLightMap, 0);\n"
"	vec3 invGridSize = vec3(1.0) / vec3(gridSize);\n"
"	vec3 gridCell = (position - u_LightGridOrigin) * u_LightGridCellInverseSize * invGridSize;\n"
"#endif\n"
"\n"
"#if defined(USE_LIGHTMAP)\n"
"	vec4 lightmapColor = texture(u_LightMap, var_TexCoords.zw);\n"
"  #if defined(RGBM_LIGHTMAP)\n"
"	lightmapColor.rgb *= lightmapColor.a;\n"
"  #endif\n"
"  #if defined(USE_PBR) && !defined(USE_FAST_LIGHT)\n"
"	lightmapColor.rgb *= lightmapColor.rgb;\n"
"  #endif\n"
"#endif\n"
"\n"
"	vec2 texCoords = var_TexCoords.xy;\n"
"\n"
"#if defined(USE_PARALLAXMAP)\n"
"	vec3 offsetDir = viewDir * tangentToWorld;\n"
"\n"
"	offsetDir.xy *= -u_NormalScale.a / offsetDir.z;\n"
"\n"
"	texCoords += offsetDir.xy * RayIntersectDisplaceMap(texCoords, offsetDir.xy, u_NormalMap);\n"
"#endif\n"
"\n"
"	vec4 diffuse = texture(u_DiffuseMap, texCoords);\n"
"#if defined(USE_ATEST)\n"
"#  if USE_ATEST == ATEST_CMP_LT\n"
"	if (diffuse.a >= u_AlphaTestValue)\n"
"#  elif USE_ATEST == ATEST_CMP_GT\n"
"	if (diffuse.a <= u_AlphaTestValue)\n"
"#  elif USE_ATEST == ATEST_CMP_GE\n"
"	if (diffuse.a < u_AlphaTestValue)\n"
"#  endif\n"
"		discard;\n"
"#endif\n"
"\n"
"#if defined(PER_PIXEL_LIGHTING)\n"
"	float isLightgrid = float(var_LightDir.w < 1.0);\n"
"	L = var_LightDir.xyz;\n"
"  #if defined(USE_LIGHT_VERTEX)\n"
"	L = -normalize(texture(u_LightGridDirectionMap, gridCell).rgb * 2.0 - vec3(1.0)) * (1.0 - u_EnableTextures.y);\n"
"  #endif\n"
"  #if defined(USE_DELUXEMAP)\n"
"	L = -normalize(texture(u_LightGridDirectionMap, gridCell).rgb  * 2.0 - vec3(1.0)) * (1.0 - u_EnableTextures.y);\n"
"	L += (texture(u_DeluxeMap, var_TexCoords.zw).xyz - vec3(0.5)) * u_EnableTextures.y;\n"
"  #endif\n"
"	float lightDist = length(L);\n"
"	L /= lightDist;\n"
"\n"
"	vec3 ambientLight = texture(u_LightGridAmbientLightMap, gridCell).rgb * isLightgrid;\n"
"  #if defined(USE_PBR)\n"
"	vertexColor = var_Color.rgb * var_Color.rgb;\n"
"	ambientLight *= ambientLight;\n"
"	#if defined(USE_LIGHT_VECTOR)\n"
"	  L -= normalize(texture(u_LightGridDirectionMap, gridCell).rgb * 2.0 - vec3(1.0)) * isLightgrid;\n"
"	  vec3 directedLight = mix(u_DirectedLight, texture(u_LightGridDirectionalLightMap, gridCell).rgb, isLightgrid);\n"
"	  directedLight *= directedLight;\n"
"	#endif\n"
"  #else\n"
"	vertexColor = var_Color.rgb;\n"
"	#if defined(USE_LIGHT_VECTOR)\n"
"	  L -= normalize(texture(u_LightGridDirectionMap, gridCell).rgb * 2.0 - vec3(1.0)) * isLightgrid;\n"
"	  vec3 directedLight = mix(u_DirectedLight, texture(u_LightGridDirectionalLightMap, gridCell).rgb, isLightgrid);\n"
"	#endif\n"
"  #endif\n"
"	ambientColor = ambientLight * vertexColor;\n"
"  #if defined(USE_LIGHTMAP)\n"
"	lightColor	 = lightmapColor.rgb * vertexColor;\n"
"	attenuation  = 1.0;\n"
"  #elif defined(USE_LIGHT_VECTOR)\n"
"	lightColor	 = directedLight * vertexColor * (var_LightDir.w + float(var_LightDir.w < 1.0));\n"
"	attenuation  = CalcLightAttenuation(lightDist, var_LightDir.w);\n"
"  #elif defined(USE_LIGHT_VERTEX)\n"
"	lightColor	 = vertexColor;\n"
"	attenuation  = 1.0;\n"
"  #endif\n"
"\n"
"	N = CalcNormal(var_Normal.xyz, texCoords, tangentToWorld);\n"
"\n"
"  #if defined(USE_SHADOWMAP) \n"
"	vec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\n"
"	float shadowValue = texture(u_ShadowMap, shadowTex).r;\n"
"\n"
"	// surfaces not facing the light are always shadowed\n"
"	shadowValue *= clamp(dot(N, var_PrimaryLightDir.xyz), 0.0, 1.0);\n"
"\n"
"    #if defined(SHADOWMAP_MODULATE)\n"
"	lightColor *= shadowValue * (1.0 - u_PrimaryLightAmbient.r) + u_PrimaryLightAmbient.r;\n"
"    #endif\n"
"  #endif\n"
"\n"
"  #if defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)\n"
"	float surfNL = clamp(dot(N, L), 0.0, 1.0) * 0.25;\n"
"	ambientColor = max(lightColor - lightColor * surfNL, vec3(0.0));\n"
"  #endif\n"
"\n"
"  #if defined(USE_SPECULARMAP)\n"
"	vec4 specular = texture(u_SpecularMap, texCoords);\n"
"  #else\n"
"	vec4 specular = vec4(1.0);\n"
"  #endif\n"
"	specular *= u_SpecularScale;\n"
"\n"
"#if defined(USE_PBR)\n"
"	diffuse.rgb *= diffuse.rgb;\n"
"	specular.rgb *= specular.rgb;\n"
"	// energy conservation, requires specular workflow to use an albedo texture too\n"
"	diffuse.rgb *= vec3(1.0) - specular.rgb;\n"
"#endif\n"
"\n"
"	// diffuse rgb is diffuse\n"
"	// specular rgb is specular reflectance at normal incidence\n"
"	// specular alpha is gloss\n"
"	float roughness = 1.0 - specular.a;\n"
"\n"
"    H  = normalize(L + E);\n"
"    EH = max(1e-8, dot(E, H));\n"
"	NH = max(1e-8, dot(N, H));\n"
"	NL = clamp(dot(N, L), 1e-8, 1.0);\n"
"	\n"
"	reflectance = CalcDiffuse(diffuse.rgb, NH, EH, roughness);\n"
"\n"
"  #if defined(USE_LIGHTMAP) || defined(USE_LIGHT_VERTEX)\n"
"	NE = abs(dot(N, E)) + 1e-5;\n"
"	reflectance += CalcSpecular(specular.rgb, NH, NL, NE, EH, roughness) * 1.0;\n"
"  #endif\n"
"  #if defined(USE_LIGHT_VECTOR)\n"
"	NE = abs(dot(N, E)) + 1e-5;\n"
"	reflectance += CalcSpecular(specular.rgb, NH, NL, NE, EH, roughness);\n"
"  #endif\n"
"\n"
"	out_Color.rgb  = lightColor   * reflectance * (attenuation * NL);\n"
"	out_Color.rgb += ambientColor * diffuse.rgb;\n"
"\n"
"  #if defined(USE_CUBEMAP)\n"
"	NE = clamp(dot(N, E), 0.0, 1.0);\n"
"	vec3 EnvBRDF = texture(u_EnvBrdfMap, vec2(roughness, NE)).rgb;\n"
"\n"
"	vec3 R = reflect(E, N);\n"
"\n"
"	// parallax corrected cubemap (cheaper trick)\n"
"	// from http://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/\n"
"	vec3 parallax = u_CubeMapInfo.xyz + u_CubeMapInfo.w * viewDir;\n"
"\n"
"	vec3 cubeLightColor = textureLod(u_CubeMap, R + parallax, ROUGHNESS_MIPS * roughness).rgb * u_EnableTextures.w;\n"
"\n"
"	float horiz = 1.0;\n"
"	// from http://marmosetco.tumblr.com/post/81245981087\n"
"	#if defined(HORIZON_FADE)\n"
"		const float horizonFade = HORIZON_FADE;\n"
"		horiz = clamp( 1.0 + horizonFade * dot(-R,var_Normal.xyz), 0.0, 1.0 );\n"
"		horiz *= horiz;\n"
"	#endif\n"
"\n"
"    #if defined(USE_PBR)\n"
"		cubeLightColor *= cubeLightColor;\n"
"    #endif\n"
"\n"
"	out_Color.rgb += cubeLightColor * (specular.rgb * EnvBRDF.x + EnvBRDF.y) * horiz;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PRIMARY_LIGHT) || defined(SHADOWMAP_MODULATE)\n"
"	vec3 L2, H2;\n"
"	float NL2, EH2, NH2, L2H2;\n"
"\n"
"	L2 = var_PrimaryLightDir.xyz;\n"
"\n"
"	H2  = normalize(L2 + E);\n"
"    NL2 = clamp(dot(N, L2), 0.0, 1.0);\n"
"    NL2 = max(1e-8, abs(NL2) );\n"
"    EH2 = max(1e-8, dot(E, H2));\n"
"    NH2 = max(1e-8, dot(N, H2));\n"
"	\n"
"	reflectance  = CalcSpecular(specular.rgb, NH2, NL2, NE, EH2, roughness);\n"
"\n"
"	// bit of a hack, with modulated shadowmaps, ignore diffuse\n"
"    #if !defined(SHADOWMAP_MODULATE)\n"
"	reflectance += CalcDiffuse(diffuse.rgb, NH2, EH2, roughness);\n"
"    #endif\n"
"\n"
"	lightColor = u_PrimaryLightColor * var_Color.rgb;\n"
"\n"
"    #if defined(USE_SHADOWMAP)\n"
"	lightColor *= shadowValue;\n"
"    #endif\n"
"\n"
"	out_Color.rgb += lightColor * reflectance * NL2;\n"
"  #endif\n"
"\n"
"  #if defined(USE_DEBUG)\n"
"	if (USE_DEBUG == 1)\n"
"		out_Color.rgb = diffuse.rgb;\n"
"	if (USE_DEBUG == 2)\n"
"		out_Color.rgb = specular.rgb;\n"
"	if (USE_DEBUG == 3)\n"
"		out_Color.rgb = N.rgb * 0.5 + 0.5;\n"
"  #endif\n"
"\n"
"  #if defined(USE_PBR)\n"
"	out_Color.rgb = sqrt(out_Color.rgb);\n"
"  #endif\n"
"\n"
"#else\n"
"	lightColor = var_Color.rgb;\n"
"	out_Color.rgb = diffuse.rgb * lightColor;\n"
"#endif\n"
"\n"
"	out_Color.a = diffuse.a * var_Color.a;\n"
"\n"
"#if defined(USE_GLOW_BUFFER)\n"
"	out_Glow = out_Color;\n"
"#else\n"
"	out_Glow = vec4(0.0);\n"
"#endif\n"
"}";
GPUShaderDesc fallback_lightallShaders[] = {
  { GPUSHADER_VERTEX, fallback_lightall_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_lightall_fp, 309 },
};
extern const GPUProgramDesc fallback_lightallProgram = { 2, fallback_lightallShaders };

const char *fallback_prefilterEnvMap_vp = "in vec4 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"out vec2 var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = attr_Position;\n"
"	var_ScreenTex = attr_TexCoord0.xy;\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
"\n"
"";
const char *fallback_prefilterEnvMap_fp = "uniform vec4 u_ViewInfo; // cubeface, mip_level, max_mip_level, 0.0\n"
"uniform samplerCube u_CubeMap;\n"
"in vec2 var_ScreenTex;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"// from http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n"
"float radicalInverse_VdC(uint bits) {\n"
"     bits = (bits << 16u) | (bits >> 16u);\n"
"     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n"
"     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n"
"     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n"
"     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n"
"     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n"
"}\n"
"\n"
"vec2 hammersley2D(uint i, uint N) {\n"
"     return vec2(float(i)/float(N), radicalInverse_VdC(i));\n"
"}\n"
"\n"
"vec3 ImportanceSampleGGX(vec2 Xi, float Roughness, vec3 N)\n"
"{\n"
"	float a = Roughness * Roughness;\n"
"	float Phi = 2 * M_PI * Xi.x;\n"
"	float CosTheta = sqrt((1-Xi.y) / (1+(a*a -1) * Xi.y));\n"
"	float SinTheta = sqrt( 1 - CosTheta * CosTheta);\n"
"\n"
"	vec3 H;\n"
"	H.x = SinTheta * cos( Phi );\n"
"	H.y = SinTheta * sin( Phi );\n"
"	H.z = CosTheta;\n"
"\n"
"	vec3 UpVector = abs(N.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);\n"
"	vec3 TangentX = normalize(cross(UpVector , N));\n"
"	vec3 TangentY = cross(N , TangentX);\n"
"\n"
"	return TangentX * H.x + TangentY * H.y + N * H.z;\n"
"}\n"
"\n"
"vec3 PrefilterEnvMap( float Roughness, vec3 R )\n"
"{\n"
"	vec3 N = R;\n"
"	vec3 V = R;\n"
"	vec3 PrefilteredColor = vec3(0.0);\n"
"	float TotalWeight = 0.0;\n"
"	uint NumSamples = uint(1024);\n"
"	for ( uint i = uint(0); i < NumSamples; i++ )\n"
"	{\n"
"		vec2 Xi = hammersley2D( i, NumSamples );\n"
"		vec3 H = ImportanceSampleGGX( Xi, Roughness, N );\n"
"		vec3 L = 2 * dot( V, H ) * H - V;\n"
"		float NoL = clamp((dot( N, L )),0.0,1.0);\n"
"		if ( NoL > 0 )\n"
"		{\n"
"			PrefilteredColor += textureLod(u_CubeMap, L, 0.0).rgb * NoL;\n"
"			TotalWeight += NoL;\n"
"		}\n"
"	}\n"
"	return PrefilteredColor / TotalWeight;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float cubeFace = u_ViewInfo.x;\n"
"	vec2 vector;\n"
"	vector.x = (var_ScreenTex.x - 0.5) * 2.0;\n"
"	vector.y = (var_ScreenTex.y - 0.5) * 2.0;\n"
"	// from http://www.codinglabs.net/article_physically_based_rendering.aspx\n"
"\n"
"	vec3 normal = normalize( vec3(vector.xy, 1) );\n"
"    if(cubeFace==2)\n"
"        normal = normalize( vec3(vector.x,  1, -vector.y) );\n"
"    else if(cubeFace==3)\n"
"        normal = normalize( vec3(vector.x, -1,  vector.y) );\n"
"    else if(cubeFace==0)\n"
"        normal = normalize( vec3(  1, vector.y,-vector.x) );\n"
"    else if(cubeFace==1)\n"
"        normal = normalize( vec3( -1, vector.y, vector.x) );\n"
"    else if(cubeFace==5)\n"
"        normal = normalize( vec3(-vector.x, vector.y, -1) );\n"
"\n"
"	float roughness = u_ViewInfo.y / u_ViewInfo.z;\n"
"	vec3 result = PrefilterEnvMap(roughness, normal);\n"
"			\n"
"	out_Color = vec4(result, 1.0);\n"
"}\n"
"";
GPUShaderDesc fallback_prefilterEnvMapShaders[] = {
  { GPUSHADER_VERTEX, fallback_prefilterEnvMap_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_prefilterEnvMap_fp, 16 },
};
extern const GPUProgramDesc fallback_prefilterEnvMapProgram = { 2, fallback_prefilterEnvMapShaders };

const char *fallback_pshadow_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec3 var_Position;\n"
"out vec3 var_Normal;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"\n"
"	var_Position  = attr_Position;\n"
"	var_Normal    = attr_Normal * 2.0 - vec3(1.0);\n"
"}\n"
"\n"
"";
const char *fallback_pshadow_fp = "uniform sampler2D u_ShadowMap;\n"
"uniform vec3 u_LightForward;\n"
"uniform vec3 u_LightUp;\n"
"uniform vec3 u_LightRight;\n"
"uniform vec4 u_LightOrigin;\n"
"uniform float u_LightRadius;\n"
"\n"
"in vec3 var_Position;\n"
"in vec3 var_Normal;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	vec3 lightToPos = var_Position - u_LightOrigin.xyz;\n"
"	vec2 st = vec2(-dot(u_LightRight, lightToPos), dot(u_LightUp, lightToPos));\n"
"\n"
"	float fade = length(st);\n"
"\n"
"#if defined(USE_DISCARD)\n"
"	if (fade >= 1.0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"#endif\n"
"\n"
"	fade = clamp(8.0 - fade * 8.0, 0.0, 1.0);\n"
"\n"
"	st = st * 0.5 + vec2(0.5);\n"
"\n"
"#if defined(USE_SOLID_PSHADOWS)\n"
"	float intensity = max(sign(u_LightRadius - length(lightToPos)), 0.0);\n"
"#else\n"
"	float intensity = clamp((1.0 - dot(lightToPos, lightToPos) / (u_LightRadius * u_LightRadius)) * 2.0, 0.0, 1.0);\n"
"#endif\n"
"\n"
"	float lightDist = length(lightToPos);\n"
"	float dist;\n"
"\n"
"#if defined(USE_DISCARD)\n"
"	if (dot(u_LightForward, lightToPos) <= 0.0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"\n"
"	if (dot(var_Normal, lightToPos) > 0.0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"#else\n"
"	intensity *= max(sign(dot(u_LightForward, lightToPos)), 0.0);\n"
"	intensity *= max(sign(-dot(var_Normal, lightToPos)), 0.0);\n"
"#endif\n"
"\n"
"	intensity *= fade;\n"
"\n"
"	float part;\n"
"#if defined(USE_PCF)\n"
"	part = float(texture(u_ShadowMap, st + vec2(-1.0 / 512.0, -1.0 / 512.0)).r != 1.0);\n"
"	part += float(texture(u_ShadowMap, st + vec2(1.0 / 512.0, -1.0 / 512.0)).r != 1.0);\n"
"	part += float(texture(u_ShadowMap, st + vec2(-1.0 / 512.0, 1.0 / 512.0)).r != 1.0);\n"
"	part += float(texture(u_ShadowMap, st + vec2(1.0 / 512.0, 1.0 / 512.0)).r != 1.0);\n"
"#else\n"
"	part = float(texture(u_ShadowMap, st).r != 1.0);\n"
"#endif\n"
"\n"
"	if (part <= 0.0)\n"
"	{\n"
"		discard;\n"
"	}\n"
"\n"
"#if defined(USE_PCF)\n"
"	intensity *= part * 0.25;\n"
"#else\n"
"	intensity *= part;\n"
"#endif\n"
"\n"
"	out_Color.rgb = vec3(.0,.0,.0);\n"
"	out_Color.a = clamp(intensity, 0.0, 0.75);\n"
"}";
GPUShaderDesc fallback_pshadowShaders[] = {
  { GPUSHADER_VERTEX, fallback_pshadow_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_pshadow_fp, 20 },
};
extern const GPUProgramDesc fallback_pshadowProgram = { 2, fallback_pshadowShaders };

const char *fallback_refraction_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform mat4 u_ModelMatrix;\n"
"uniform vec3 u_ViewOrigin;\n"
"\n"
"uniform vec4 u_PrimaryLightOrigin;\n"
"uniform float u_PrimaryLightRadius;\n"
"\n"
"out vec4 var_PrimaryLightDir;\n"
"\n"
"out vec2 var_Tex1;\n"
"out vec2 fragpos;\n"
"out vec3 normal;\n"
"out vec3 position;\n"
"out vec3 viewDir;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position 	= u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_Tex1 		= attr_TexCoord0.st;\n"
"	fragpos			= (gl_Position.xy / gl_Position.w) *0.5 + 0.5; //perspective divide/normalize\n"
"\n"
"	position  		= (u_ModelMatrix * vec4(attr_Position , 1.0)).xyz;\n"
"	normal    		= attr_Normal;\n"
"	normal			= normal  * 2.0 - vec3(1.0);\n"
"	//normal    		= ((u_ModelMatrix * vec4(normal , 0.0)).xyz);\n"
"	viewDir			= u_ViewOrigin - position.xyz;\n"
"\n"
"	var_PrimaryLightDir.xyz = u_PrimaryLightOrigin.xyz - (position * u_PrimaryLightOrigin.w);\n"
"	var_PrimaryLightDir.w = u_PrimaryLightRadius * u_PrimaryLightRadius;\n"
"}\n"
"\n"
"";
const char *fallback_refraction_fp = "/*\n"
"* Liquid shader based on:\n"
"* \"Seascape\" by Alexander Alekseev aka TDM - 2014\n"
"* Contact: tdmaav@gmail.com\n"
"*/\n"
"\n"
"const float etaR = 0.65;\n"
"const float etaG = 0.67; // Ratio of indices of refraction\n"
"const float etaB = 0.69;\n"
"const float fresnelPower = 2.0;\n"
"const float F = ((1.0 - etaG) * (1.0 - etaG)) / ((1.0 + etaG) * (1.0 + etaG));\n"
"\n"
"uniform sampler2D	u_DiffuseMap;\n"
"uniform samplerCube u_CubeMap;\n"
"uniform vec4		u_CubeMapInfo;\n"
"uniform vec4 u_Color;\n"
"\n"
"uniform sampler2D u_ShadowMap;\n"
"uniform vec3  u_PrimaryLightColor;\n"
"uniform vec3  u_PrimaryLightAmbient;\n"
"\n"
"layout(std140) uniform Liquid\n"
"{\n"
"float		isLiquid;\n"
"float		height;\n"
"float		choppy;\n"
"float		speed;\n"
"float		freq;\n"
"float		depth;\n"
"float		time;\n"
"};\n"
"\n"
"layout(std140) uniform Liquid2\n"
"{\n"
"float		water_color_r;\n"
"float		water_color_g;\n"
"float		water_color_b;\n"
"float		fog_color_r;\n"
"float		fog_color_g;\n"
"float		fog_color_b;\n"
"};\n"
"\n"
"in vec2 fragpos;\n"
"in vec3 position;\n"
"in vec3 normal;\n"
"in vec3 viewDir;\n"
"\n"
"in vec4 var_PrimaryLightDir;\n"
"\n"
"out vec4 out_Color;\n"
"out vec4 out_Glow;\n"
"\n"
"#define EPSILON_NRM (.2 / 1920)\n"
"const int NUM_STEPS = 8;\n"
"const float EPSILON = 1e-3;\n"
"const int ITER_GEOMETRY = 3;\n"
"const int ITER_FRAGMENT = 5;\n"
"const mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);\n"
"float SEA_TIME = 1.0 + time * speed;\n"
"\n"
"float hash(vec2 p) {\n"
"	float h = dot(p, vec2(127.1, 311.7));\n"
"	return fract(sin(h)*43758.5453123);\n"
"}\n"
"float noise(in vec2 p) {\n"
"	vec2 i = floor(p);\n"
"	vec2 f = fract(p);\n"
"	vec2 u = f*f*(3.0 - 2.0*f);\n"
"	return -1.0 + 2.0*mix(mix(hash(i + vec2(0.0, 0.0)),\n"
"		hash(i + vec2(1.0, 0.0)), u.x),\n"
"		mix(hash(i + vec2(0.0, 1.0)),\n"
"			hash(i + vec2(1.0, 1.0)), u.x), u.y);\n"
"}\n"
"\n"
"float diffuse(vec3 n, vec3 l, float p) {\n"
"	return pow(dot(n, l) * 0.4 + 0.6, p);\n"
"}\n"
"\n"
"vec3 specular(vec3 n, vec3 l, vec3 e, float s) {\n"
"\n"
"	vec2 shadowTex = gl_FragCoord.xy * r_FBufScale;\n"
"	float shadowValue = texture(u_ShadowMap, shadowTex).r;\n"
"\n"
"	// surfaces not facing the light are always shadowed\n"
"	shadowValue *= clamp(dot(n, -l), 0.0, 1.0);\n"
"\n"
"	float nrm = (s + 8.0) / (M_PI * 8.0);\n"
"	vec3 lightColor = u_PrimaryLightColor * (pow(max(dot(reflect(e, n), -l), 0.0), s) * nrm);\n"
"\n"
"	return (lightColor * shadowValue);\n"
"}\n"
"\n"
"float sea_octave(vec2 uv, float choppy) {\n"
"	uv += noise(uv);\n"
"	vec2 wv = 1.0 - abs(sin(uv));\n"
"	vec2 swv = abs(cos(uv));\n"
"	wv = mix(wv, swv, wv);\n"
"	return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n"
"}\n"
"\n"
"\n"
"float map(vec3 p) {\n"
"	float freq = freq;\n"
"	float amp = height;\n"
"	float choppy = choppy;\n"
"	vec2 uv = p.xy; uv.x *= 0.75;\n"
"\n"
"	float d, h = 0.0;\n"
"	for (int i = 0; i < ITER_GEOMETRY; i++) {\n"
"		d = sea_octave((uv + SEA_TIME)*freq, choppy);\n"
"		d += sea_octave((uv - SEA_TIME)*freq, choppy);\n"
"		h += d * amp;\n"
"		uv *= octave_m; freq *= 1.9; amp *= 0.22;\n"
"		choppy = mix(choppy, 1.0, 0.2);\n"
"	}\n"
"	return p.z - h;\n"
"}\n"
"\n"
"float map_detailed(vec3 p) {\n"
"	float freq = freq;\n"
"	float amp = height;\n"
"	float choppy = choppy;\n"
"	vec2 uv = p.xy; uv.x *= 0.75;\n"
"\n"
"	float d, h = 0.0;\n"
"	for (int i = 0; i < ITER_FRAGMENT; i++) {\n"
"		d = sea_octave((uv + SEA_TIME)*freq, choppy);\n"
"		d += sea_octave((uv - SEA_TIME)*freq, choppy);\n"
"		h += d * amp;\n"
"		uv *= octave_m; freq *= 1.9; amp *= 0.22;\n"
"		choppy = mix(choppy, 1.0, 0.2);\n"
"	}\n"
"	return p.z - h;\n"
"}\n"
"\n"
"\n"
"vec3 getNormal(vec3 p, float eps) {\n"
"	vec3 n;\n"
"	n.z = map_detailed(p);\n"
"	n.x = map_detailed(vec3(p.x + eps, p.y, p.z)) - n.z;\n"
"	n.y = map_detailed(vec3(p.x, p.y + eps, p.z)) - n.z;\n"
"	n.z = eps;\n"
"	return normalize(n);\n"
"}\n"
"\n"
"float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {\n"
"	float tm = 0.0;\n"
"	float tx = 1000.0;\n"
"	float hx = map(ori + dir * tx);\n"
"	if (hx > 0.0) return tx;\n"
"	float hm = map(ori + dir * tm);\n"
"	float tmid = 0.0;\n"
"	for (int i = 0; i < NUM_STEPS; i++) {\n"
"		tmid = mix(tm, tx, hm / (hm - hx));\n"
"		p = ori + dir * tmid;\n"
"		float hmid = map(p);\n"
"		if (hmid < 0.0) {\n"
"			tx = tmid;\n"
"			hx = hmid;\n"
"		}\n"
"		else {\n"
"			tm = tmid;\n"
"			hm = hmid;\n"
"		}\n"
"	}\n"
"	return tmid;\n"
"}\n"
"\n"
"vec3 getSkyColor(vec3 n) {\n"
"	vec3 i = normalize(viewDir);\n"
"\n"
"	vec3 parallax = u_CubeMapInfo.xyz + u_CubeMapInfo.w * viewDir;\n"
"	vec3 cubeLightColor = texture(u_CubeMap, reflect(i, n) + parallax).rgb;\n"
"	return cubeLightColor;\n"
"}\n"
"\n"
"vec3 getGroundColor(vec3 n) {\n"
"	vec3 i = normalize(viewDir);\n"
"\n"
"	vec3 cubeLightColor = vec3(texture(u_CubeMap, refract(i, n, 0.948)).r, texture(u_CubeMap, refract(i, n, 0.95)).g, texture(u_CubeMap, refract(i, n, 0.952)).b);\n"
"	return cubeLightColor;\n"
"}\n"
"\n"
"vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {\n"
"	vec3 i = normalize(viewDir);\n"
"\n"
"	float fresnel = clamp(1.0 - dot(n, -i), 0.0, 1.0);\n"
"	fresnel = pow(fresnel, 3.0) * 0.65;\n"
"\n"
"	vec3 water_color = vec3(water_color_r, water_color_g, water_color_b);\n"
"	vec3 fog_color = vec3(fog_color_r, fog_color_g, fog_color_b);\n"
"\n"
"	vec3 groundColor = vec3(.4, .3, .2);\n"
"\n"
"	vec3 reflected = getSkyColor(n);\n"
"	vec3 refracted = fog_color + diffuse(n,l,80) * water_color * 0.12;\n"
"	//vec3 refracted = mix(groundColor, fog_color /*+ diffuse(n,l,80)*/ * water_color * 0.12, depth);\n"
"	//refracted.r = mix(texture(u_CubeMap, refract(eye, n, 0.948)).rbg, (fog_color + diffuse(n, l, 80.0) * water_color * 0.12), .1).r;\n"
"	//refracted.g = mix(texture(u_CubeMap, refract(eye, n, 0.95)).rbg, (fog_color + diffuse(n, l, 80.0) * water_color * 0.12), .1).g;\n"
"	//refracted.b = mix(texture(u_CubeMap, refract(eye, n, 0.952)).rbg, (fog_color + diffuse(n, l, 80.0) * water_color * 0.12), .1).b;\n"
"\n"
"	vec3 color = mix(refracted, reflected, fresnel);\n"
"\n"
"	float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);\n"
"	color += water_color * (p.z - height) * 0.18 * atten;\n"
"\n"
"	color += specular(n, l, i, 60.0);\n"
"\n"
"	return color;\n"
"}\n"
"\n"
"void main()\n"
"{	\n"
"	vec3 n = normalize(normal);\n"
"	vec3 refractColor;\n"
"	\n"
"	float alpha;\n"
"	vec3 eye = normalize(viewDir);\n"
"\n"
"	if (isLiquid == 1) \n"
"	{\n"
"		// based on https://www.shadertoy.com/view/Ms2SD1\n"
"		eye.z -= 2.0;\n"
"		vec3 ori = position.xyz;\n"
"		\n"
"		vec3 p;\n"
"		heightMapTracing(ori, eye, p);\n"
"		vec3 dist = p - ori;\n"
"\n"
"		n = getNormal(p, dot(viewDir, viewDir) * EPSILON_NRM);\n"
"		vec3 color = getSeaColor(p, -n, var_PrimaryLightDir.xyz, eye, dist);\n"
"		\n"
"		refractColor = vec3(pow(color, vec3(0.75)));\n"
"\n"
"		alpha = .80;\n"
"		alpha += depth * 0.2;\n"
"	}\n"
"	else\n"
"	{\n"
"		\n"
"		float ratio = F + (1.0 - F) * pow(1.0 - dot(-eye, n), fresnelPower);\n"
"		vec3	refractR = normalize(refract(eye, n, etaR));\n"
"		vec3	refractG = normalize(refract(eye, n, etaG));\n"
"		vec3	refractB = normalize(refract(eye, n, etaB));\n"
"\n"
"		refractR = refractR - eye;\n"
"		refractG = refractG - eye;\n"
"		refractB = refractB - eye;\n"
"		refractColor.r = texture(u_DiffuseMap, fragpos + (refractR.xy * 0.1)).r;\n"
"		refractColor.g = texture(u_DiffuseMap, fragpos + (refractG.xy * 0.1)).g;\n"
"		refractColor.b = texture(u_DiffuseMap, fragpos + (refractB.xy * 0.1)).b;\n"
"\n"
"		vec3 combinedColor = mix(refractColor, u_Color.rgb, ratio);\n"
"		refractColor = combinedColor;\n"
"		alpha = 1.0;\n"
"	}\n"
"\n"
"	out_Color = vec4((refractColor), alpha);\n"
"	out_Glow = vec4(0.0);\n"
"}\n"
"";
GPUShaderDesc fallback_refractionShaders[] = {
  { GPUSHADER_VERTEX, fallback_refraction_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_refraction_fp, 38 },
};
extern const GPUProgramDesc fallback_refractionProgram = { 2, fallback_refractionShaders };

const char *fallback_shadowfill_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"in vec3 attr_Position2;\n"
"in vec3 attr_Normal2;\n"
"\n"
"uniform int u_DeformType;\n"
"uniform int u_DeformFunc;\n"
"uniform float u_DeformParams[7];\n"
"\n"
"uniform float u_Time;\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"uniform float u_VertexLerp;\n"
"\n"
"float GetNoiseValue( float x, float y, float z, float t )\n"
"{\n"
"	// Variation on the 'one-liner random function'.\n"
"	// Not sure if this is still 'correctly' random\n"
"	return fract( sin( dot(\n"
"		vec4( x, y, z, t ),\n"
"		vec4( 12.9898, 78.233, 12.9898, 78.233 )\n"
"	)) * 43758.5453 );\n"
"}\n"
"\n"
"float CalculateDeformScale( in int func, in float time, in float phase, in float frequency )\n"
"{\n"
"	float value = phase + time * frequency;\n"
"\n"
"	switch ( func )\n"
"	{\n"
"		case WF_SIN:\n"
"			return sin(value * 2.0 * M_PI);\n"
"		case WF_SQUARE:\n"
"			return sign(0.5 - fract(value));\n"
"		case WF_TRIANGLE:\n"
"			return abs(fract(value + 0.75) - 0.5) * 4.0 - 1.0;\n"
"		case WF_SAWTOOTH:\n"
"			return fract(value);\n"
"		case WF_INVERSE_SAWTOOTH:\n"
"			return 1.0 - fract(value);\n"
"		default:\n"
"			return 0.0;\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformPosition(const vec3 pos, const vec3 normal, const vec2 st)\n"
"{\n"
"	switch ( u_DeformType )\n"
"	{\n"
"		default:\n"
"		{\n"
"			return pos;\n"
"		}\n"
"\n"
"		case DEFORM_BULGE:\n"
"		{\n"
"			float bulgeHeight = u_DeformParams[1]; // amplitude\n"
"			float bulgeWidth = u_DeformParams[2]; // phase\n"
"			float bulgeSpeed = u_DeformParams[3]; // frequency\n"
"\n"
"			float scale = CalculateDeformScale( WF_SIN, u_Time, bulgeWidth * st.x, bulgeSpeed );\n"
"\n"
"			return pos + normal * scale * bulgeHeight;\n"
"		}\n"
"\n"
"		case DEFORM_WAVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			float spread = u_DeformParams[4];\n"
"\n"
"			float offset = dot( pos.xyz, vec3( spread ) );\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase + offset, frequency );\n"
"\n"
"			return pos + normal * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_MOVE:\n"
"		{\n"
"			float base = u_DeformParams[0];\n"
"			float amplitude = u_DeformParams[1];\n"
"			float phase = u_DeformParams[2];\n"
"			float frequency = u_DeformParams[3];\n"
"			vec3 direction = vec3( u_DeformParams[4], u_DeformParams[5], u_DeformParams[6] );\n"
"\n"
"			float scale = CalculateDeformScale( u_DeformFunc, u_Time, phase, frequency );\n"
"\n"
"			return pos + direction * (base + scale * amplitude);\n"
"		}\n"
"\n"
"		case DEFORM_PROJECTION_SHADOW:\n"
"		{\n"
"			vec3 ground = vec3(\n"
"				u_DeformParams[0],\n"
"				u_DeformParams[1],\n"
"				u_DeformParams[2]);\n"
"			float groundDist = u_DeformParams[3];\n"
"			vec3 lightDir = vec3(\n"
"				u_DeformParams[4],\n"
"				u_DeformParams[5],\n"
"				u_DeformParams[6]);\n"
"\n"
"			float d = dot( lightDir, ground );\n"
"\n"
"			lightDir = lightDir * max( 0.5 - d, 0.0 ) + ground;\n"
"			d = 1.0 / dot( lightDir, ground );\n"
"\n"
"			vec3 lightPos = lightDir * d;\n"
"\n"
"			return pos - lightPos * dot( pos, ground ) + groundDist;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"vec3 DeformNormal( const in vec3 position, const in vec3 normal )\n"
"{\n"
"	if ( u_DeformType != DEFORM_NORMALS )\n"
"	{\n"
"		return normal;\n"
"	}\n"
"\n"
"	float amplitude = u_DeformParams[1];\n"
"	float frequency = u_DeformParams[3];\n"
"\n"
"	vec3 outNormal = normal;\n"
"	const float scale = 0.98;\n"
"	\n"
"	outNormal.x += amplitude * GetNoiseValue(\n"
"		position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.y += amplitude * GetNoiseValue(\n"
"		100.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	outNormal.z += amplitude * GetNoiseValue(\n"
"		200.0 * position.x * scale,\n"
"		position.y * scale,\n"
"		position.z * scale,\n"
"		u_Time * frequency );\n"
"\n"
"	return outNormal;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 position  = mix(attr_Position, attr_Position2, u_VertexLerp);\n"
"	vec3 normal    = mix(attr_Normal,   attr_Normal2,   u_VertexLerp);\n"
"	normal = normalize(normal - vec3(0.5));\n"
"\n"
"	position = DeformPosition(position, normal, attr_TexCoord0.st);\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(position, 1.0);\n"
"}\n"
"\n"
"";
const char *fallback_shadowfill_fp = "out vec4 out_Color;\n"
"void main()\n"
"{\n"
"	out_Color = vec4(0, 0, 0, 1);\n"
"}\n"
"";
GPUShaderDesc fallback_shadowfillShaders[] = {
  { GPUSHADER_VERTEX, fallback_shadowfill_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_shadowfill_fp, 165 },
};
extern const GPUProgramDesc fallback_shadowfillProgram = { 2, fallback_shadowfillShaders };

const char *fallback_shadowmask_vp = "in vec4 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform vec3 u_ViewForward;\n"
"uniform vec3 u_ViewLeft;\n"
"uniform vec3 u_ViewUp;\n"
"uniform vec4 u_ViewInfo; // zfar / znear\n"
"\n"
"out vec2 var_DepthTex;\n"
"out vec3 var_ViewDir;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = attr_Position;\n"
"	vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	var_DepthTex = attr_TexCoord0.xy;\n"
"	var_ViewDir = u_ViewForward + u_ViewLeft * -screenCoords.x + u_ViewUp * screenCoords.y;\n"
"}\n"
"\n"
"";
const char *fallback_shadowmask_fp = "uniform sampler2D u_ScreenDepthMap;\n"
"\n"
"uniform sampler2DShadow u_ShadowMap;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform sampler2DShadow u_ShadowMap2;\n"
"uniform sampler2DShadow u_ShadowMap3;\n"
"uniform sampler2DShadow u_ShadowMap4;\n"
"#endif\n"
"\n"
"uniform mat4 u_ShadowMvp;\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"uniform mat4 u_ShadowMvp2;\n"
"uniform mat4 u_ShadowMvp3;\n"
"uniform mat4 u_ShadowMvp4;\n"
"#endif\n"
"\n"
"uniform vec3 u_ViewOrigin;\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"in vec2 var_DepthTex;\n"
"in vec3 var_ViewDir;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"// depth is GL_DEPTH_COMPONENT24\n"
"// so the maximum error is 1.0 / 2^24\n"
"#define DEPTH_MAX_ERROR 0.000000059604644775390625\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random(const vec2 p)\n"
"{\n"
"	// We need irrationals for pseudo randomness.\n"
"	// Most (all?) known transcendental numbers will (generally) work.\n"
"	const vec2 r = vec2(\n"
"		23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"		2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"							 //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"	return mod(123456789., 1e-7 + 256. * dot(p, r));\n"
"}\n"
"\n"
"float PCF(const sampler2DShadow shadowmap, const vec2 st, const float dist)\n"
"{\n"
"	float mult;\n"
"	float scale = 2.0 / r_shadowMapSize;\n"
"\n"
"#if 0\n"
"	// from http://http.developer.nvidia.com/GPUGems/gpugems_ch11.html\n"
"	vec2 offset = vec2(greaterThan(fract(var_DepthTex.xy * r_FBufScale * 0.5), vec2(0.25)));\n"
"	offset.y += offset.x;\n"
"	if (offset.y > 1.1) offset.y = 0.0;\n"
"\n"
"	mult = texture (shadowmap, vec3(st + (offset + vec2(-1.5, 0.5)) * scale, dist))\n"
"		+ texture (shadowmap, vec3(st + (offset + vec2(0.5, 0.5)) * scale, dist))\n"
"		+ texture (shadowmap, vec3(st + (offset + vec2(-1.5, -1.5)) * scale, dist))\n"
"		+ texture (shadowmap, vec3(st + (offset + vec2(0.5, -1.5)) * scale, dist));\n"
"\n"
"	mult *= 0.25;\n"
"#endif\n"
"\n"
"#if defined(USE_SHADOW_FILTER)\n"
"	float r = random(var_DepthTex.xy);\n"
"	float sinr = sin(r) * scale;\n"
"	float cosr = cos(r) * scale;\n"
"	mat2 rmat = mat2(cosr, sinr, -sinr, cosr);\n"
"\n"
"	mult = texture (shadowmap, vec3(st + rmat * vec2(-0.7055767, 0.196515), dist));\n"
"	mult += texture (shadowmap, vec3(st + rmat * vec2(0.3524343, -0.7791386), dist));\n"
"	mult += texture (shadowmap, vec3(st + rmat * vec2(0.2391056, 0.9189604), dist));\n"
"#if defined(USE_SHADOW_FILTER2)\n"
"	mult += texture (shadowmap, vec3(st + rmat * vec2(-0.07580382, -0.09224417), dist));\n"
"	mult += texture (shadowmap, vec3(st + rmat * vec2(0.5784913, -0.002528916), dist));\n"
"	mult += texture (shadowmap, vec3(st + rmat * vec2(0.192888, 0.4064181), dist));\n"
"	mult += texture (shadowmap, vec3(st + rmat * vec2(-0.6335801, -0.5247476), dist));\n"
"	mult += texture (shadowmap, vec3(st + rmat * vec2(-0.5579782, 0.7491854), dist));\n"
"	mult += texture (shadowmap, vec3(st + rmat * vec2(0.7320465, 0.6317794), dist));\n"
"\n"
"	mult *= 0.11111;\n"
"#else\n"
"	mult *= 0.33333;\n"
"#endif\n"
"#else\n"
"	mult = texture (shadowmap, vec3(st, dist));\n"
"#endif\n"
"\n"
"	return mult;\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, vec2 tex, float zFarDivZNear)\n"
"{\n"
"	float sampleZDivW = texture2D(depthMap, tex).r - DEPTH_MAX_ERROR;\n"
"	return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float result;\n"
"\n"
"	float depth = getLinearDepth(u_ScreenDepthMap, var_DepthTex, u_ViewInfo.x);\n"
"	vec4 biasPos = vec4(u_ViewOrigin + var_ViewDir * (depth - 0.5 / u_ViewInfo.x), 1.0);\n"
"\n"
"	vec4 shadowpos = u_ShadowMvp * biasPos;\n"
"\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"	if (all(lessThan(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"	{\n"
"#endif\n"
"		shadowpos.xyz = shadowpos.xyz * (0.5 / shadowpos.w) + vec3(0.5);\n"
"		result = PCF(u_ShadowMap, shadowpos.xy, shadowpos.z);\n"
"#if defined(USE_SHADOW_CASCADE)\n"
"	}\n"
"	else\n"
"	{\n"
"		shadowpos = u_ShadowMvp2 * biasPos;\n"
"\n"
"		if (all(lessThan(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"		{\n"
"			shadowpos.xyz = shadowpos.xyz * (0.5 / shadowpos.w) + vec3(0.5);\n"
"			result = PCF(u_ShadowMap2, shadowpos.xy, shadowpos.z);\n"
"		}\n"
"		else\n"
"		{\n"
"			shadowpos = u_ShadowMvp3 * biasPos;\n"
"\n"
"			if (all(lessThan(abs(shadowpos.xyz), vec3(abs(shadowpos.w)))))\n"
"			{\n"
"				shadowpos.xyz = shadowpos.xyz * (0.5 / shadowpos.w) + vec3(0.5);\n"
"				result = PCF(u_ShadowMap3, shadowpos.xy, shadowpos.z);\n"
"			}\n"
"			else\n"
"			{\n"
"				shadowpos = u_ShadowMvp4 * biasPos;\n"
"				shadowpos.xyz = shadowpos.xyz * (0.5 / shadowpos.w) + vec3(0.5);\n"
"				result = PCF(u_ShadowMap4, shadowpos.xy, shadowpos.z);\n"
"			}\n"
"		}\n"
"	}\n"
"#endif\n"
"		\n"
"	out_Color = vec4(vec3(result), 1.0);\n"
"}\n"
"";
GPUShaderDesc fallback_shadowmaskShaders[] = {
  { GPUSHADER_VERTEX, fallback_shadowmask_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_shadowmask_fp, 22 },
};
extern const GPUProgramDesc fallback_shadowmaskProgram = { 2, fallback_shadowmaskShaders };

const char *fallback_ssao_vp = "in vec4 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"out vec2 var_ScreenTex;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = attr_Position;\n"
"	var_ScreenTex = attr_TexCoord0.xy;\n"
"	//vec2 screenCoords = gl_Position.xy / gl_Position.w;\n"
"	//var_ScreenTex = screenCoords * 0.5 + 0.5;\n"
"}\n"
"\n"
"";
const char *fallback_ssao_fp = "uniform sampler2D u_ScreenDepthMap;\n"
"uniform vec4 u_ViewInfo; // zfar / znear, zfar\n"
"\n"
"in vec2 var_ScreenTex;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"vec2 poissonDisc[9] = vec2[9](\n"
"vec2(-0.7055767, 0.196515),    vec2(0.3524343, -0.7791386),\n"
"vec2(0.2391056, 0.9189604),    vec2(-0.07580382, -0.09224417),\n"
"vec2(0.5784913, -0.002528916), vec2(0.192888, 0.4064181),\n"
"vec2(-0.6335801, -0.5247476),  vec2(-0.5579782, 0.7491854),\n"
"vec2(0.7320465, 0.6317794)\n"
");\n"
"\n"
"// Input: It uses texture coords as the random number seed.\n"
"// Output: Random number: [0,1), that is between 0.0 and 0.999999... inclusive.\n"
"// Author: Michael Pohoreski\n"
"// Copyright: Copyleft 2012 :-)\n"
"// Source: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader\n"
"\n"
"float random( const vec2 p )\n"
"{\n"
"  // We need irrationals for pseudo randomness.\n"
"  // Most (all?) known transcendental numbers will (generally) work.\n"
"  const vec2 r = vec2(\n"
"    23.1406926327792690,  // e^pi (Gelfond's constant)\n"
"     2.6651441426902251); // 2^sqrt(2) (Gelfond-Schneider constant)\n"
"  //return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );\n"
"  return mod( 123456789., 1e-7 + 256. * dot(p,r) );  \n"
"}\n"
"\n"
"mat2 randomRotation( const vec2 p )\n"
"{\n"
"	float r = random(p);\n"
"	float sinr = sin(r);\n"
"	float cosr = cos(r);\n"
"	return mat2(cosr, sinr, -sinr, cosr);\n"
"}\n"
"\n"
"float getLinearDepth(sampler2D depthMap, const vec2 tex, const float zFarDivZNear)\n"
"{\n"
"		float sampleZDivW = texture(depthMap, tex).r;\n"
"		return 1.0 / mix(zFarDivZNear, 1.0, sampleZDivW);\n"
"}\n"
"\n"
"float ambientOcclusion(sampler2D depthMap, const vec2 tex, const float zFarDivZNear, const float zFar)\n"
"{\n"
"	float result = 0;\n"
"\n"
"	float sampleZ = zFar * getLinearDepth(depthMap, tex, zFarDivZNear);\n"
"\n"
"	vec2 expectedSlope = vec2(dFdx(sampleZ), dFdy(sampleZ)) / vec2(dFdx(tex.x), dFdy(tex.y));\n"
"	\n"
"	if (length(expectedSlope) > 5000.0)\n"
"		return 1.0;\n"
"	\n"
"	vec2 offsetScale = vec2(3.0 / sampleZ);\n"
"	\n"
"	mat2 rmat = randomRotation(tex);\n"
"		\n"
"	int i;\n"
"	for (i = 0; i < 9; i++)\n"
"	{\n"
"		vec2 offset = rmat * poissonDisc[i] * offsetScale;\n"
"		float sampleZ2 = zFar * getLinearDepth(depthMap, tex + offset, zFarDivZNear);\n"
"\n"
"		if (abs(sampleZ - sampleZ2) > 20.0)\n"
"			result += 1.0;\n"
"		else\n"
"		{\n"
"			float expectedZ = sampleZ + dot(expectedSlope, offset);\n"
"			result += step(expectedZ - 1.0, sampleZ2);\n"
"		}\n"
"	}\n"
"	\n"
"	result *= 0.11111;\n"
"	\n"
"	return result;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float result = ambientOcclusion(u_ScreenDepthMap, var_ScreenTex, u_ViewInfo.x, u_ViewInfo.y);\n"
"			\n"
"	out_Color = vec4(vec3(result), 1.0);\n"
"}\n"
"";
GPUShaderDesc fallback_ssaoShaders[] = {
  { GPUSHADER_VERTEX, fallback_ssao_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_ssao_fp, 16 },
};
extern const GPUProgramDesc fallback_ssaoProgram = { 2, fallback_ssaoShaders };

const char *fallback_surface_sprites_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Normal;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform vec3 u_ViewOrigin;\n"
"\n"
"layout(std140) uniform SurfaceSprite\n"
"{\n"
"	float u_Width;\n"
"	float u_Height;\n"
"	float u_FadeStartDistance;\n"
"	float u_FadeEndDistance;\n"
"	float u_FadeScale;\n"
"	float u_WidthVariance;\n"
"	float u_HeightVariance;\n"
"};\n"
"\n"
"out vec2 var_TexCoords;\n"
"out float var_Alpha;\n"
"\n"
"float random(vec2 n)\n"
"{\n"
"	return fract(sin(dot(n.xy, vec2(12.9898,78.233))) * 43758.5453);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec3 V = u_ViewOrigin - attr_Position;\n"
"\n"
"	float width = u_Width * (1.0 + u_WidthVariance*random(attr_Position.xz));\n"
"	float height = u_Height * (1.0 + u_HeightVariance*random(attr_Position.xz));\n"
"\n"
"	float distanceToCamera = length(V);\n"
"	float fadeScale = smoothstep(u_FadeStartDistance, u_FadeEndDistance,\n"
"						distanceToCamera);\n"
"	width += u_FadeScale * fadeScale * u_Width;\n"
"\n"
"	float halfWidth = width * 0.5;\n"
"	vec3 offsets[] = vec3[](\n"
"#if defined(FACE_UP)\n"
"		vec3( halfWidth, -halfWidth, 0.0),\n"
"		vec3( halfWidth,  halfWidth, height),\n"
"		vec3(-halfWidth,  halfWidth, height),\n"
"		vec3(-halfWidth, -halfWidth, 0.0)\n"
"#else\n"
"		vec3( halfWidth, 0.0, 0.0),\n"
"		vec3( halfWidth, 0.0, height),\n"
"		vec3(-halfWidth, 0.0, height),\n"
"		vec3(-halfWidth, 0.0, 0.0)\n"
"#endif\n"
"	);\n"
"\n"
"	const vec2 texcoords[] = vec2[](\n"
"		vec2(1.0, 1.0),\n"
"		vec2(1.0, 0.0),\n"
"		vec2(0.0, 0.0),\n"
"		vec2(0.0, 1.0)\n"
"	);\n"
"\n"
"	vec3 offset = offsets[gl_VertexID];\n"
"\n"
"#if defined(FACE_CAMERA)\n"
"	//TODO: Allow facing the camera on the z axis as well to match GL1.\n"
"	vec2 toCamera = normalize(V.xy);\n"
"	offset.xy = offset.x*vec2(toCamera.y, -toCamera.x);\n"
"#elif defined(FACE_UP)\n"
"	// Incorrect. Copied the FACE_CAMERA code (orients sprite only on X & Y axis) for FACE_UP instead. Now matches GL1.\n"
"	// Make this sprite face in some direction\n"
"	//offset.xy = offset.x*attr_Normal.xy;\n"
"	vec2 toCamera = normalize(V.xy);\n"
"	offset.xy = offset.x*vec2(toCamera.y, -toCamera.x);\n"
"#endif\n"
"\n"
"	vec4 worldPos = vec4(attr_Position + offset, 1.0);\n"
"	gl_Position = u_ModelViewProjectionMatrix * worldPos;\n"
"	var_TexCoords = texcoords[gl_VertexID];\n"
"	var_Alpha = 1.0 - fadeScale;\n"
"}\n"
"\n"
"";
const char *fallback_surface_sprites_fp = "uniform sampler2D u_DiffuseMap;\n"
"\n"
"in vec2 var_TexCoords;\n"
"in float var_Alpha;\n"
"\n"
"#if defined(ALPHA_TEST)\n"
"uniform float u_AlphaTestValue;\n"
"#endif\n"
"\n"
"layout(std140) uniform SurfaceSprite\n"
"{\n"
"	float u_Width;\n"
"	float u_Height;\n"
"	float u_FadeStartDistance;\n"
"	float u_FadeEndDistance;\n"
"	float u_FadeScale;\n"
"	float u_WidthVariance;\n"
"	float u_HeightVariance;\n"
"};\n"
"\n"
"out vec4 out_Color;\n"
"out vec4 out_Glow;\n"
"\n"
"void main()\n"
"{\n"
"	const float alphaTestValue = 0.5;\n"
"	out_Color = texture(u_DiffuseMap, var_TexCoords);\n"
"	out_Color.a *= var_Alpha*(1.0 - alphaTestValue) + alphaTestValue;\n"
"\n"
"#if defined(ALPHA_TEST)\n"
"	if ( out_Color.a < alphaTestValue )\n"
"		discard;\n"
"#endif\n"
"\n"
"	out_Glow = vec4(0.0);\n"
"}\n"
"";
GPUShaderDesc fallback_surface_spritesShaders[] = {
  { GPUSHADER_VERTEX, fallback_surface_sprites_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_surface_sprites_fp, 82 },
};
extern const GPUProgramDesc fallback_surface_spritesProgram = { 2, fallback_surface_spritesShaders };

const char *fallback_texturecolor_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_Tex1;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_Tex1 = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_texturecolor_fp = "uniform sampler2D u_DiffuseMap;\n"
"uniform vec4 u_Color;\n"
"\n"
"in vec2 var_Tex1;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	out_Color = texture(u_DiffuseMap, var_Tex1) * u_Color;\n"
"}\n"
"";
GPUShaderDesc fallback_texturecolorShaders[] = {
  { GPUSHADER_VERTEX, fallback_texturecolor_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_texturecolor_fp, 17 },
};
extern const GPUProgramDesc fallback_texturecolorProgram = { 2, fallback_texturecolorShaders };

const char *fallback_tonemap_vp = "in vec3 attr_Position;\n"
"in vec4 attr_TexCoord0;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"\n"
"out vec2 var_TexCoords;\n"
"\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = u_ModelViewProjectionMatrix * vec4(attr_Position, 1.0);\n"
"	var_TexCoords = attr_TexCoord0.st;\n"
"}\n"
"\n"
"";
const char *fallback_tonemap_fp = "uniform sampler2D u_TextureMap;\n"
"uniform sampler2D u_LevelsMap;\n"
"uniform vec4 u_Color;\n"
"uniform vec2  u_AutoExposureMinMax;\n"
"uniform vec3   u_ToneMinAvgMaxLinear;\n"
"\n"
"in vec2 var_TexCoords;\n"
"\n"
"out vec4 out_Color;\n"
"\n"
"const vec3  LUMINANCE_VECTOR =   vec3(0.2125, 0.7154, 0.0721); //vec3(0.299, 0.587, 0.114);\n"
"\n"
"vec3 LinearTosRGB( in vec3 color )\n"
"{\n"
"	vec3 clampedColor = clamp(color, 0.0, 1.0);\n"
"\n"
"	vec3 lo = 12.92 * clampedColor;\n"
"	vec3 hi = 1.055 * pow(clampedColor, vec3(0.41666)) - 0.055;\n"
"	return mix(lo, hi, greaterThanEqual(color, vec3(0.0031308)));\n"
"}\n"
"\n"
"vec3 FilmicTonemap(vec3 x)\n"
"{\n"
"	const float SS  = 0.22; // Shoulder Strength\n"
"	const float LS  = 0.30; // Linear Strength\n"
"	const float LA  = 0.10; // Linear Angle\n"
"	const float TS  = 0.20; // Toe Strength\n"
"	const float TAN = 0.01; // Toe Angle Numerator\n"
"	const float TAD = 0.30; // Toe Angle Denominator\n"
"	\n"
"	vec3 SSxx = SS * x * x;\n"
"	vec3 LSx = LS * x;\n"
"	vec3 LALSx = LSx * LA;\n"
"	\n"
"	return ((SSxx + LALSx + TS * TAN) / (SSxx + LSx + TS * TAD)) - TAN / TAD;\n"
"\n"
"	//return ((x*(SS*x+LA*LS)+TS*TAN)/(x*(SS*x+LS)+TS*TAD)) - TAN/TAD;\n"
"\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	vec4 color = texture(u_TextureMap, var_TexCoords) * u_Color;\n"
"#if defined(USE_PBR)\n"
"	color.rgb = pow(color.rgb, vec3(2.2));\n"
"#endif\n"
"	vec3 minAvgMax = texture(u_LevelsMap, var_TexCoords).rgb;\n"
"	vec3 logMinAvgMaxLum = clamp(minAvgMax * 20.0 - 10.0, -u_AutoExposureMinMax.y, -u_AutoExposureMinMax.x);\n"
"		\n"
"	float avgLum = exp2(logMinAvgMaxLum.y);\n"
"	//float maxLum = exp2(logMinAvgMaxLum.z);\n"
"\n"
"	color.rgb *= u_ToneMinAvgMaxLinear.y / avgLum;\n"
"	color.rgb = max(vec3(0.0), color.rgb - vec3(u_ToneMinAvgMaxLinear.x));\n"
"\n"
"	vec3 fWhite = 1.0 / FilmicTonemap(vec3(u_ToneMinAvgMaxLinear.z - u_ToneMinAvgMaxLinear.x));\n"
"	color.rgb = FilmicTonemap(color.rgb) * fWhite;\n"
"	//color.rgb = LinearTosRGB(color.rgb);\n"
"\n"
"#if defined(USE_PBR)\n"
"	color.rgb = pow(color.rgb, vec3(1.0 / 2.2));\n"
"#endif\n"
"	\n"
"	out_Color = clamp(color, 0.0, 1.0);\n"
"}\n"
"";
GPUShaderDesc fallback_tonemapShaders[] = {
  { GPUSHADER_VERTEX, fallback_tonemap_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_tonemap_fp, 17 },
};
extern const GPUProgramDesc fallback_tonemapProgram = { 2, fallback_tonemapShaders };

const char *fallback_weather_vp = "in vec3 attr_Position;\n"
"in vec3 attr_Color;\n"
"\n"
"uniform vec2 u_MapZExtents;\n"
"uniform float u_Time;\n"
"uniform vec3 u_ViewOrigin;\n"
"\n"
"void main()\n"
"{\n"
"	int z = gl_InstanceID / 25;\n"
"	int remaining = gl_InstanceID - (z * 25);\n"
"	int y = remaining % 5;\n"
"	int x = remaining / 5;\n"
"\n"
"	float zOffset = mod(\n"
"		1000.0 * float(z) + u_Time * 1000.0,\n"
"		u_MapZExtents.y - u_MapZExtents.x - 2000.0);\n"
"	vec3 offset = vec3(\n"
"		1000.0 * float(x - 2),\n"
"		1000.0 * float(y - 2),\n"
"		u_MapZExtents.y - zOffset);\n"
"	offset.xy += attr_Color.xy * u_Time;\n"
"\n"
"	gl_Position = vec4(attr_Position + offset, 1.0);\n"
"}\n"
"\n"
"";
const char *fallback_weather_fp = "out vec4 out_Color;\n"
"\n"
"void main()\n"
"{\n"
"	out_Color = vec4(0.7, 0.8, 0.7, 0.4);\n"
"}\n"
"";
const char *fallback_weather_gp = "layout(points) in;\n"
"layout(triangle_strip, max_vertices = 4) out;\n"
"\n"
"uniform mat4 u_ModelViewProjectionMatrix;\n"
"uniform vec3 u_ViewOrigin;\n"
"\n"
"void main()\n"
"{\n"
"	const vec2 offsets[] = vec2[](\n"
"		vec2(-0.5, -7.0),\n"
"		vec2( 0.5, -7.0),\n"
"		vec2(-0.5,  7.0),\n"
"		vec2( 0.5,  7.0)\n"
"	);\n"
"\n"
"	vec3 P = gl_in[0].gl_Position.xyz;\n"
"	vec3 V = u_ViewOrigin - P;\n"
"	vec2 toCamera = normalize(vec2(V.y, -V.x));\n"
"\n"
"	for (int i = 0; i < 4; ++i)\n"
"	{\n"
"		vec3 offset = vec3(offsets[i].x * toCamera.xy, offsets[i].y);\n"
"		vec4 worldPos = vec4(P + offset, 1.0);\n"
"		gl_Position = u_ModelViewProjectionMatrix * worldPos;\n"
"		EmitVertex();\n"
"	}\n"
"\n"
"	EndPrimitive();\n"
"}\n"
"\n"
"";
GPUShaderDesc fallback_weatherShaders[] = {
  { GPUSHADER_VERTEX, fallback_weather_vp, 2 },
  { GPUSHADER_FRAGMENT, fallback_weather_fp, 60 },
  { GPUSHADER_GEOMETRY, fallback_weather_gp, 29 },
};
extern const GPUProgramDesc fallback_weatherProgram = { 3, fallback_weatherShaders };

